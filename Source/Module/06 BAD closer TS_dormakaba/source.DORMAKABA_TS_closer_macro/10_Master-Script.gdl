! ######################################
!
! BIM-all-doors - DOOR SYSTEM
!
! Module: Door closing system
!
! Manufacturer: DORMAKABA
! Linie: OTS, BTS, ITS
!
! Product content © 2021 BY DORMAKABA
!
! (p) 2018-2021 BY DORMAKABA / WRITTEN BY FRANK BEISTER
! openSource by CCO1.0 license since 2025
!
! https://github.com/dormakaba/bim-all-doors
! 
! #############################################################################

! =============================================================================
! GLOBAL SETTINGS
! =============================================================================

! »»» Arrays

DIM clr1[], clr2[][], UI_page_subs[]
DIM UI_page_names[], UI_page_icons[], UI_page_type[]


! »»» Constants

tlr = 0.00001 	!»» accurancy
version = 1.90	!»» Objektversion
txt = ""	  	!»»  Text für alles
txt2 = ""	  	!»»  ...
praefix = ""	!»»  Vortext 
sts = 0 : sts2 = 0 : sts3 = 0 	!»»  Statusflags 

! »»» Localization

sprache = language  !»»  Deutsch


! »»» Common keywords

IF sprache = 1 THEN

	commonMacro = "allgemein" 
	commonKey = "unspezifiziert" 
	naKey = "[-]"  !"undefiniert" 
	noKey = "nein" 
	yesKey = "ja"
	offKey = "Aus"

	ELSE

	commonMacro = "allgemein"  !"generic"
	commonKey = "unspecific"
	naKey = "[-]"  !"common"
	noKey = "no"
	yesKey = "yes"
	offKey = "off"

	ENDIF

! ----------------------------------- INDEX NAMES OF ARRAY PARAMETERS (start)

! --------- PRODUCT PARAMETERS

! --------- sProdukte[i][…]
	dki_PRODUKT = 1
	dki_ART = 2
	dki_TYP = 3
	dki_VERZOEGERUNG = 4
	dki_FESTSTELLUNG = 5
! --------- iProdukte[i][…]
	dki_TYP2 = 2
	dki_MONTAGE = 1
	dki_EN = 3
	dki_FLUEGEL = 4
	dki_SEITE = 6
	dki_RAUCHMELDER = 5
! --------- eigenschaften[i][…]
	dki_BRANDSCHUTZ = 1
	dki_BARRIEREFREI = 2
	dki_SCHLIESSFOLGE = 3
	dki_DAEMPFUNG = 4
! --------- dimensionK[i][…]
	dki_xT_MT1 = 1
	dki_zT_MT1 = 2
	dki_xT_MT2 = 3
	dki_zT_MT2 = 4
	dki_xT_MT3 = 5
	dki_zT_MT3 = 6
	dki_xT_MT4 = 7
	dki_zT_MT4 = 8
	dki_xT_MT5 = 9
	dki_zT_MT5 = 10
! --------- dimensionG[i][…]
	dki_xG_MT1 = 1
	dki_zG_MT1 = 2
	dki_xG_MT2 = 3
	dki_zG_MT2 = 4
	dki_xG_MT3 = 5
	dki_zG_MT3 = 6
	dki_xG_MT4 = 7
	dki_zG_MT4 = 8
	dki_xG_MT5 = 9
	dki_zG_MT5 = 10
! --------- abmessungG[i][…]
	dki_sx = 1
	dki_sz = 3
	dki_sy = 2
	dki_yL = 4
	dki_xH = 5
	dki_xkD = 6
	dki_ykD = 7
	dki_LaBS = 8
! --------- abmessungK[i][…]
	dki_kx = 1
	dki_ky = 2
	dki_kz = 3
! --------- DEFAULT VALUE ARRAYS

! --------- dk_folding_dimensions[i][…]
	dki_Falz1 = 1
	dki_Falz2 = 2
! --------- dk_panel_folding_dimensions[i][…]
	dki_Mittelfalz1 = 1
	dki_Mittelfalz2 = 2
	dki_Mittelfalz3 = 3
! --------- dk_open_leaf[i][…]
	dka_leaf_angle2D = 1
	dka_leaf2_angle2D = 2
	dka_leaf_angleSA = 3
	dka_leaf2_angleSA = 4
	dka_leaf_angle3D = 5
	dka_leaf2_angle3D = 6
! --------- dk_cont_pens[i][…]
	dka_handle_penC2 = 1
	dka_handle_penC3 = 2
	dka_frame_penC2 = 3
	dka_frame_penC3 = 4
	dka_panel_penC2 = 5
	dka_panel_penC3 = 6
	dka_opline2D = 7
	dka_oplineSA = 8
	dka_opline3D = 9
	dka_topview_penC2 = 10
	dka_penInvisible = 11
	dka_closer_penSA = 12
	dka_closer_penC3 = 13
	dka_automation_penSA = 14
	dka_automation_penC3 = 15
! --------- dk_fill_pens[i][…]
	dka_handle_penF = 1
	dka_frame_penF = 2
	dka_side1_penF = 3
	dka_side2_penF = 4
	dka_panel_penF = 5
	dka_panelfill1_penF = 6
	dka_panelfill2_penF = 7
	dka_panelfill3_penF = 8
	dka_panel2fill1_penF = 9
	dka_panel2fill2_penF = 10
	dka_panel2fill3_penF = 11
	dka_topview_penF = 12
	dka_fan_penF = 13
	dka_penF = 14
	dka_penF = 15
! --------- dk_bkg_pens[i][…]
	dka_handle_penB = 1
	dka_frame_penB = 2
	dka_side1_penB = 3
	dka_side2_penB = 4
	dka_panel_penB = 5
	dka_panelfill1_penB = 6
	dka_panelfill2_penB = 7
	dka_panelfill3_penB = 8
	dka_panel2fill1_penB = 9
	dka_panel2fill2_penB = 10
	dka_panel2fill3_penB = 11
	dka_topview_penB = 12
	dka_fan_penB = 13
	dka_penB = 14
	dka_penB = 15
! --------- dk_fills[i][…]
	dka_handle_fill = 1
	dka_frame_fill = 2
	dka_side1_fill = 3
	dka_side2_fill = 4
	dka_panel_fill = 5
	dka_panelfill1_fill = 6
	dka_panelfill2_fill = 7
	dka_panelfill3_fill = 8
	dka_panel2fill1_fill = 9
	dka_panel2fill2_fill = 10
	dka_panel2fill3_fill = 11
	dka_topview_fill = 12
	dka_fan_fill = 13
	dka_fill = 14
	dka_fill = 15
! --------- dk_linetype[i][…]
	dka_invisible = 1
! --------- dk_materials[i][…]
	dka_handle_mat = 1
	dka_plate_mat = 2
	dka_frame_mat_BS = 3
	dka_frame_mat_BGS = 4
	dka_side1_mat_BS = 5
	dka_side1_mat_BGS = 6
	dka_side2_mat_BS = 7
	dka_side2_mat_BGS = 8
	dka_fan_mat_BS = 9
	dka_fan_mat_BGS = 10
	dka_panel_mat_BS = 11
	dka_panel_mat_BGS = 12
	dka_panelfill1_mat_BS = 13
	dka_panelfill1_mat_BGS = 14
	dka_panelfill2_mat_BS = 15
	dka_panelfill2_mat_BGS = 16
	dka_panelfill3_mat_BS = 17
	dka_panelfill3_mat_BGS = 18
	dka_panel2_mat_BS = 19
	dka_panel2_mat_BGS = 20
	dka_panel2fill1_mat_BS = 21
	dka_panel2fill1_mat_BGS = 22
	dka_panel2fill2_mat_BS = 23
	dka_panel2fill2_mat_BGS = 24
	dka_panel2fill3_mat_BS = 25
	dka_panel2fill3_mat_BGS = 26
	dka_panel_bandings_mat = 27
	dka_panel2_bandings_mat = 28
	dka_hinge_mat = 29
	dka_closer_mat = 30
	dka_automation_mat = 31
	dka_grip_mat_BS1 = 32
	dka_grip_mat_BS2 = 33
	dka_grip_mat_BGS1 = 34
	dka_grip_mat_BGS2 = 35

! ----------------------------------- INDEX NAMES OF ARRAY PARAMETERS (end)

! ----------------------------------- MULTILINGUAL TEXT [ECD.closer] (start)

! --------- RESET array variables
	DIM uiTXT[]

! --------- User Interface - UI_xxxFIELD text (Deutsch)
	IF language = 1 THEN
		uiTXT[1] = "TÜRSCHLIESSER - Anforderungen"
		uiTXT[2] = " ... Standflügel + Darstellung"
		uiTXT[3] = " ... Darstellung"
		uiTXT[4] = "TÜRSCHLIESSER"
		uiTXT[5] = "Gangflügel"
		uiTXT[6] = "Standflügel"
		ENDIF
! --------- User Interface - UI_xxxFIELD text (Englisch)
	IF language = 4 THEN
		uiTXT[1] = "DOOR CLOSER - demands"
		uiTXT[2] = " ... inactive door leaf + representation"
		uiTXT[3] = " ... representation"
		uiTXT[4] = "DOOR CLOSER"
		uiTXT[5] = "active door leaf"
		uiTXT[6] = "inactive door leaf"
		ENDIF

! ----------------------------------- MULTILINGUAL TEXT (end)

! ------------------------------------------------------------------------ [ Konstruktionstyp ermitteln ]

! »»» Falzart
IF bs_leaf_oversize < tlr OR bs_leaf_overhang < tlr THEN stumpf = 1 ELSE stumpf = 0

! »»» Ist da was über dem Türblatt?
oberLichtBlende = gs_door_transom * (1 + (bs_inner_frame = 2))  ! 1: Oberlicht, 2:Oberblende

! »»» Automation
IF bs_automation_type = "-" OR bs_door_leafs < 1 THEN
	automation = 0
	ELSE
	IF bs_door_leafs = 1 THEN
		automation = 1
		ELSE
		IF bs_automation_type = "GF" THEN automation = 1
		IF bs_automation_type = "2E" OR bs_automation_type = "2S" OR bs_automation_type = "GS" THEN automation = 2
		ENDIF	
	ENDIF

! »»» Gestängetürschließer
schere = (bs_slider_system = "S" AND bs_closer_type = "OTS")

! »»» Montagevarianten Schließer: 
	! Horizontal | Vertikal - montageTYP = montageart (= Bitnummer + 1)
	! OTS:    BS | T - MV_T1 = 1   (Bit: 0)   BGS | S - MV_T2 = 2   (Bit: 1)   BS  | S - MV_T3 = 4   (Bit: 2)   BGS | T - MV_T4 = 8 (Bit: 3)
	! ITS:    M  | T - MV_T6 = 32  (Bit: 5)   M   | K - MV_T7 = 64 ( Bit: 6)
	! BTS:    BS | B - MV_T8 = 128 (Bit: 7)   M   | B - MV_T9 = 256 (Bit: 8)
IF bs_closer_type = "BTS" THEN
	montageOTS = 8
	ELSE
	IF bs_closer_type = "ITS" THEN
		montageOTS =	6*(bs_closer_position="T") + \
						7*(bs_closer_position="S")
		ELSE   ! ... OTS / ED
		! OTS Schiene  |  Schere/Gestänge
		montageOTS =	(1*(bs_closer_orientation="GS" & bs_closer_position="S") + \
						 2*(bs_closer_orientation="BS" & bs_closer_position="S") + \
						 3*(bs_closer_orientation="GS" & bs_closer_position="T")) + 1
		ENDIF
	ENDIF


! ------------------------------------------------------------------------[ environment ]

! »»» Seitenfelder?
! IF bs_door_sidelight = "L" OR bs_door_sidelight = "LR" THEN gs_sidelight_left = 1  ELSE gs_sidelight_left = 0
! IF bs_door_sidelight = "R" OR bs_door_sidelight = "LR" THEN gs_sidelight_right = 1 ELSE gs_sidelight_right = 0

! »»» Separater Aufruf der Flügel?
stand = BITTEST(macro_runtype,2)

! »»» Spiegelung wg. Beschriftung
IF ac_OpeningSide ="L" THEN
	gespiegelt = 1 - stand
	ELSE
	gespiegelt = 0 + stand
	ENDIF

! »»» Welche Fehlermeldungen sammeln (GF/SF)

IF macro_runtype=256 THEN curInfo = 1+2 ELSE curInfo = 0

! »»» Fehlermeldungen
DIM errorQ[]
errorI = 0
errorQ[1] = ""


! =============================================================================
! Defiition UI-Seiten / LoI
! =============================================================================

!  UI_page_type =  -2 > sub of ROOT, -1 > sub of last, 1 > sub 	of first macro page

seiten = 0

IF dk_LOI > 4 AND bs_door_leafs > 0 AND NOT(automation = bs_door_leafs) THEN
	seiten = 1
	IF bs_door_leafs > 1 THEN
		IF automation = 1 THEN txt = uiTXT[6] ELSE txt = uiTXT[5]
		ELSE
		txt = ""
		ENDIF
	UI_page_names[seiten] = uiTXT[1] + " " + txt  ! "TÜRSCHLIESSER - Anforderungen"
	UI_page_icons[seiten] = "dk_title_closer 18x18.png"
	UI_page_type[seiten]  = -1
	UI_page_subs[seiten] = 6500
	IF macro_runtype=128 AND UIpage_number=1 THEN curInfo = ( 1 + 2 * (bs_closer2 > 0) ) * (bs_closer_type # "-")
	ENDIF

IF dk_LOI > 4 AND bs_door_leafs > 0 AND bs_closer_type # "-" AND NOT(automation = bs_door_leafs) THEN
	IF bs_door_leafs > 1 AND bs_closer2 = 3 THEN
		seiten = seiten + 1
		UI_page_names[seiten] = uiTXT[2]  ! " ... Standflügel + Darstellung"
		UI_page_icons[seiten] = "dk_title_closer_settings 18x18.png"
		UI_page_type[seiten]  = 1
		UI_page_subs[seiten] = 6700
		ELSE
		seiten = seiten + 1
		UI_page_names[seiten] = uiTXT[3]  ! " ... Darstellung"
		UI_page_icons[seiten] = "dk_title_closer_settings 18x18.png"
		UI_page_type[seiten]  = 1
		UI_page_subs[seiten] = 6650
		ENDIF
	IF macro_runtype=128 AND UIpage_number=2 THEN curInfo = 1 + 2 * (bs_closer2 > 0)
	ENDIF

IF dk_LOI = 4 AND bs_door_leafs > 0 AND NOT(automation = bs_door_leafs) THEN
	seiten = 1
	UI_page_names[seiten] = uiTXT[4]  ! "TÜRSCHLIESSER"
	UI_page_icons[seiten] = "dk_title_closer 18x18.png"
	UI_page_type[seiten]  = -1
	UI_page_subs[seiten] = 6800
	IF macro_runtype=128 AND UIpage_number=1 THEN curInfo = ( 1 + 2 * (bs_closer2 > 0) ) * (bs_closer_type # "-")
	ENDIF

IF dk_LOI < 4 AND bs_door_leafs > 0 AND NOT(automation = bs_door_leafs) THEN
	seiten = 1
	UI_page_names[seiten] = uiTXT[4]  ! "TÜRSCHLIESSER"
	UI_page_icons[seiten] = "dk_title_closer 18x18.png"
	UI_page_type[seiten]  = -1
	UI_page_subs[seiten] = 6900
	IF macro_runtype=128 AND UIpage_number=1 THEN curInfo = ( 1 + 2 * (bs_closer2 > 0) ) * (bs_closer_type # "-")
	ENDIF

! Makroende, wenn nur Voranfrage
IF macro_runtype = 1   THEN END UI_page_type   ! »»» return UI page hirarchy
IF macro_runtype = 2   THEN END UI_page_names  ! »»» return UI page names
IF macro_runtype = 4   THEN END UI_page_icons  ! »»» return UI page picts


! =============================================================================
! G A N G F L Ü G E L  -  Typen nach Anforderungen ermitteln
! =============================================================================

! ----------------------------------------------------------------- Arrays definieren und initialisiseren ...

DIM UIcloserModelPic[], UIcloserModelText[], UIcloserModelVal[]
DIM VALcloserModel[]
n = 1
UIcloserModelPic[n] = 0 : UIcloserModelText[n] = offKey : UIcloserModelVal[n] = "-"
VALcloserModel[n] = "-"

! »»» Initialisierung
n = 0 : k = 0 : GOSUB "ResetKonstanten"

! »»» gewählte Körperserie ermitteln
sts = SPLIT(bs_closer_model, "%s %n %s", txt, serie, txt)
XEA = (STRSTR(bs_closer_model, "XEA") > 0)

! ----------------------------------------------------------------- Produktliste sichten und passende für Auswahl

IF bs_closer_type # "-" AND NOT( bs_closer2 = 0 OR bs_closer2 = 2 ) THEN  ! AND BITTEST(macro_runtype,0)

	! ------------------------------------------------------------- Produktinfo aus Array aller Schließer

	FOR i=1 TO VARDIM1(sProdukte)

		IF  iProdukte[i][dki_SEITE] < 2 AND \
			( (((sProdukte[i][dki_ART] = "G" OR sProdukte[i][dki_ART] = "X") AND bs_slider_system = "G" ) AND bs_closer_type = "OTS" ) OR \
			((sProdukte[i][dki_ART] = "S" AND bs_slider_system = "S" ) AND bs_closer_type = "OTS" ) OR \
			(sProdukte[i][dki_ART] = "I" AND bs_closer_type = "ITS" ) OR \
			(sProdukte[i][dki_ART] = "B" AND bs_closer_type = "BTS" )) THEN

			! »»» Prüfen, ob Produkt auf Anforderung passt

			insert = 0 : infoE = ""
			sts = 0 : sts2 = 0 : sts3 = 0 ! Wenn sts wahr, dann Fehler

			! Eignung bzgl. Türflügel-Anzahl
			IF iProdukte[i][dki_FLUEGEL] # 3 AND \
				(( iProdukte[i][dki_FLUEGEL] > bs_door_leafs ) OR \
				(bs_door_leafs = 2 AND NOT(BITTEST(bs_closer2,2)) AND iProdukte[i][dki_FLUEGEL] = 2 )) THEN sts2=BITSET(sts2, 0)

			! Brandschutz
			IF bs_demand_FireResistance = 1 AND \
				( NOT(eigenschaften[i][dki_BRANDSCHUTZ]) OR \
				(iProdukte[i][dki_FLUEGEL] # 2 AND bs_door_leafs = 2) ) THEN sts=BITSET(sts, 1)

			! Dämpfung
			IF NOT(eigenschaften[i][dki_DAEMPFUNG]) AND bs_closer_damping = 1 AND bs_closer_type # "ITS" THEN sts=BITSET(sts, 2)

			! Schließverzögerung  = "-", "F", "V"
			IF bs_closer_delay # "-" AND \
				((bs_closer_delay = "F" AND sProdukte[i][dki_VERZOEGERUNG] # "F") OR \
				( bs_closer_delay = "V" AND sProdukte[i][dki_VERZOEGERUNG] = "")) THEN sts=BITSET(sts, 4)

			! Schließfolgeregelung
			IF NOT(eigenschaften[i][dki_SCHLIESSFOLGE]) AND bs_closing_order = 1 AND bs_door_leafs = 2 THEN sts=BITSET(sts, 5)

			! Barrierefreiheit
			IF NOT(eigenschaften[i][dki_BARRIEREFREI]) AND bs_demand_Accessibility = 1 THEN sts=BITSET(sts, 6)

			! Feststellung  = "-", "M", "E", "R", "B"
			IF bs_closer_fix # "-" AND (bs_closer_fix # sProdukte[i][dki_FESTSTELLUNG]) THEN sts=BITSET(sts, 7)

			! »»» Entspricht Produkt der bisherigen Auswahl (ggf. auch wennn unpassend, wenn sonst noch keines gepasst hat)

			IF bs_closer_model = sProdukte[i][dki_PRODUKT] AND bs_closer_model # "" AND ((sts = 0 AND sts2 = 0) OR selectedS = 0) THEN
				! den zuletzt gewählten in jedem erstmal aufnehmen
				GOSUB "setBody"
				GOSUB "ckeck4fit" ! Prüfen auch mit berechneten Eigenschaften
				ELSE
				! enegere Auswahl: Passen denn auch die Geometrien?
				IF (sts = 0 AND sts2 = 0) THEN
					GOSUB "readBody"
					GOSUB "ckeck4fit" ! Prüfen auch mit berechneten Eigenschaften
					ENDIF
				ENDIF

			! »»» In die Auswahlliste aufnehmen?

			IF sProdukte[i][dki_PRODUKT] = UIcloserModelVal[ MAX(1, k) ] THEN
				! Ist der letzte Produkteintrag identisch, jedoch ungeeignet?
				IF (sts = 0 AND sts2 = 0) THEN
					UIcloserModelText[k] = sProdukte[i][dki_PRODUKT]
					errorI = 0 ! evt. bestehenden Fehlerstatus löschen
					ENDIF
				insert = 0
				ELSE
				insert = ((sts = 0 AND sts2 = 0) OR selectedS=i)
				ENDIF

	   		! »»» Listeneintrag für UI aufnehmen

	   		IF insert THEN
				k=k+1 : GOSUB "addSystem2UI"
				ELSE
				! DEVELOP. Alle aufnehmen:
				IF develop = 8 AND NOT(insert) THEN
					k = k + 1
					UIcloserModelPic[k] = 0
					UIcloserModelVal[k] = sProdukte[i][dki_PRODUKT]
					UIcloserModelText[k] = "{ " + sProdukte[i][dki_PRODUKT] + " } " + STR(sts,1,0) + "/" + STR(sts2,1,0) + \
						 " | " + STR(sx*1000,1,0) + "/" + STR(sG*1000,1,0) + "/" + STR(s*1000,1,0)
						 sx = 0 : sG = 0
					ENDIF
				ENDIF

	   		! »»» In jedem Fall aber in VALUES aufnehmen

			IF sProdukte[i][dki_PRODUKT] # "" THEN
				IF n=0 THEN
					! erster wird immer aufgenommen
					n = n+1 : VALcloserModel[n] = sProdukte[i][dki_PRODUKT]
					ELSE
					IF sProdukte[i][dki_PRODUKT] # VALcloserModel[n] THEN ! identisch mit letztem Eintrag?
						n = n+1 : VALcloserModel[n] = sProdukte[i][dki_PRODUKT]
						ENDIF
					ENDIF
				ENDIF

			ENDIF

		NEXT i

	! Der derzeit eingestellte nicht in der Auswahlliste?
	IF selectedS < 1 OR bs_closer_model = "-" THEN
		IF n > 0 THEN
			! Es gibt eine Auswahlliste. Erst besten suchen:
			FOR j = 1 TO n
				FOR i = 1 TO VARDIM1(sProdukte)
					IF VALcloserModel[j] = sProdukte[i][dki_PRODUKT] THEN
						! Element gefunden
						IF selectedS = 0 THEN selectedS = -i
						! Entspricht Element auch den Anforderungen?
						FOR k = 1 TO VARDIM1(UIcloserModelText)
							IF sProdukte[i][dki_PRODUKT] = UIcloserModelText[k] THEN
								! Element gefunden
								selectedS = -i
								k = 999 : i = 999 : j = 999
								ENDIF
							NEXT k
						ENDIF
					NEXT i
				NEXT j
			ELSE
			! Es gibt keine Auswahlliste. 1. Element des Typs (als unpassend) aus Gesamtliste wählen
			selectedS = -2
			FOR i=1 TO VARDIM1(sProdukte)
				IF  iProdukte[i][dki_SEITE] < 2 AND \
					( (((sProdukte[i][dki_ART] = "G" OR sProdukte[i][dki_ART] = "X") AND bs_slider_system = "G" ) AND bs_closer_type = "OTS" ) OR \
					((sProdukte[i][dki_ART] = "S" AND bs_slider_system = "S" ) AND bs_closer_type = "OTS" ) OR \
					(sProdukte[i][dki_ART] = "I" AND bs_closer_type = "ITS" ) OR \
					(sProdukte[i][dki_ART] = "B" AND bs_closer_type = "BTS" )) THEN
					! Element gefunden
					selectedS = -i
					n = 1 : VALcloserModel[n] = sProdukte[i][dki_PRODUKT]
					sts = 1 : sts3 = 0 : k = 1 : GOSUB "addSystem2UI"
					i = 999
					ENDIF
				NEXT i			
			ENDIF

		ENDIF

	! Daten des gewälten oder vorgeschlagenen nochmal lesen
	i = ABS(selectedS) : IF i > 0 THEN GOSUB "readBody"

	ENDIF


! ------------------------------------------------------------- Check auf Grundanforderungen

IF curInfo AND ( bs_ac_closing = "PS" OR bs_ac_closing = "GS" ) AND bs_closer_type = "-" THEN
	errorI = errorI+1 : errorQ[errorI] = "Nach Funktionsanforderung fehlt ein Türschließer."
	ENDIF


! =============================================================================
! S T A N D F L Ü G E L  -  Typen nach Anforderungen ermitteln
! =============================================================================

! bs_closer2 =
	! 0: Aus
	! 1: nur Gangflügel
	! 2: nur Standflügel
	! 3: Beidseitig individuell
	! 7: wie Gangflügel

! ----------------------------------------------------------------- Arrays definieren und initialisiseren ...

DIM UIcloser2ModelPic[], UIcloser2ModelText[], UIcloser2ModelVal[]
DIM VALcloser2Model[]
n = 1
UIcloser2ModelPic[n] = 0 : UIcloser2ModelText[n] = offKey : UIcloser2ModelVal[n] = "-"
VALcloser2Model[n] = "-"

! »»» Initialisierung
n = 0 : k = 0 : m = 0 : GOSUB "ResetKonstanten2"

! »»» gewählte Körperserie ermitteln
sts = SPLIT(bs_closer_model2, "%s %n %s", txt, serie2, txt)
XEA2 = (STRSTR(bs_closer_model, "XEA") > 0)

! ----------------------------------------------------------------- Produktliste sichten und passende für Auswahl

IF bs_closer_type # "-" THEN  ! AND BITTEST(macro_runtype,1)

	IF bs_closer2 = 2 OR bs_closer2 = 3 THEN  ! ->  individueller Schließer (auch) auf SF

		! Standflügel kann individuelle Ausstattung erhalten. 
		! Also nochmal die Produktliste für SF durchpflügen

		! ------------------------------------------------------------- Produktinfo aus Array aller Schließer

		FOR i=1 TO VARDIM1(sProdukte)

			IF  ( iProdukte[i][dki_SEITE] = 0 OR iProdukte[i][dki_SEITE] = 2  ) AND \
				( (((sProdukte[i][dki_ART] = "G" OR sProdukte[i][dki_ART] = "X") AND bs_slider_system = "G" ) AND bs_closer_type = "OTS" ) OR \
				((sProdukte[i][dki_ART] = "S" AND bs_slider_system = "S" ) AND bs_closer_type = "OTS" ) OR \
				(sProdukte[i][dki_ART] = "I" AND bs_closer_type = "ITS" ) OR \
				(sProdukte[i][dki_ART] = "B" AND bs_closer_type = "BTS" )) THEN

				! »»» Prüfen, ob Produkt auf Anforderung passt

				insert = 0 : infoE = ""
				sts = 0 : sts2 = 0 : sts3 = 0 ! Wenn sts wahr, dann Fehler

				! Gleiche Serie?
				IF STRSUB(sProdukte[i][dki_TYP], 1, 2) # STR(serie,2,0) AND BITTEST(bs_closer2,0) THEN sts=BITSET(sts, 0)

				! Türflügel
				IF iProdukte[i][dki_FLUEGEL] # 1 THEN sts2=BITSET(sts2, 0)

				! Brandschutz
				IF bs_demand_FireResistance = 1 AND NOT(eigenschaften[i][dki_BRANDSCHUTZ]) THEN sts=BITSET(sts, 1)

				! Dämpfung
				IF NOT(eigenschaften[i][dki_DAEMPFUNG]) AND bs_closer_damping2 = 1 AND bs_closer_type # "ITS" THEN sts=BITSET(sts, 2)

				! Schließverzögerung  = "-", "F", "V"
				! IF bs_closer_delay # "-" AND \
				! 	((bs_closer_delay = "F" AND sProdukte[i][dki_VERZOEGERUNG] # "F") OR \
				! 	( bs_closer_delay = "V" AND sProdukte[i][dki_VERZOEGERUNG] = "")) THEN sts=BITSET(sts, 4)

				! Schließfolgeregelung nicht zulässig bei SF
				IF eigenschaften[i][dki_SCHLIESSFOLGE] AND einszwei # 2 THEN sts=BITSET(sts, 5)

				! Barrierefreiheit
				IF NOT(eigenschaften[i][dki_BARRIEREFREI]) AND bs_demand_Accessibility = 1 THEN sts=BITSET(sts, 6)

				! Feststellung  = "-", "M", "E"
				IF bs_closer_fix2 # "-" AND (bs_closer_fix2 # sProdukte[i][dki_FESTSTELLUNG]) THEN sts=BITSET(sts, 7)
				! nicht zulässig bei SF :  "R", "B"
				IF (sProdukte[i][dki_FESTSTELLUNG] = "R" OR sProdukte[i][dki_FESTSTELLUNG] = "B") AND einszwei # 2 THEN sts=BITSET(sts, 7)

				! »»» Entspricht Produkt der bisherigen Auswahl (ggf. auch wennn unpassend, wenn sonst noch keines gepasst hat)

				IF bs_closer_model2 = sProdukte[i][dki_PRODUKT] AND bs_closer_model2 # "" AND ((sts = 0 AND sts2 = 0) OR selectedS2 = 0) THEN
					! den zuletzt gewählten in jedem erstmal aufnehmen
					GOSUB "setBody2"
					GOSUB "ckeck4fit2"  ! Prüfen auch mit berechneten Eigenschaften
					ELSE
					! enegere Auswahl: Passen denn auch die Geometrien?
					IF (sts = 0 AND sts2 = 0) THEN
						GOSUB "readBody2"
						GOSUB "ckeck4fit2" ! Prüfen auch mit berechneten Eigenschaften
						ENDIF
					ENDIF

				! »»» In die Auswahlliste aufnehmen?

				IF sProdukte[i][dki_PRODUKT] = UIcloser2ModelVal[ MAX(1, k) ] THEN
					! Ist der letzte Produkteintrag identisch, jedoch ungeeignet?
					IF (sts = 0 AND sts2 = 0) THEN
						UIcloser2ModelText[k] = sProdukte[i][dki_PRODUKT]
						errorI = 0 ! evt. bestehenden Fehlerstatus löschen
						ENDIF
					insert = 0
					ELSE
					insert = ((sts = 0 AND sts2 = 0) OR selectedS2=i)
					ENDIF

		   		! »»» Listeneintrag für UI aufnehmen

		   		IF insert THEN
					k = k+1 : GOSUB "addSystem2UI2"
					ELSE
					! DEVELOP. Alle aufnehmen:
					IF develop = 8 AND NOT(insert) THEN
						k = k + 1
						UIcloser2ModelPic[k]  = 0
						UIcloser2ModelVal[k]  = sProdukte[i][dki_PRODUKT]
						UIcloser2ModelText[k] = "{ " + sProdukte[i][dki_PRODUKT] + " } " + STR(sts,1,0)
						ENDIF

					ENDIF

		   		! »»» In jedem Fall aber in VALUES aufnehmen

				IF sProdukte[i][dki_PRODUKT] # "" THEN
					IF n=0 THEN
						! erster wird immer aufgenommen
						n = n+1 : VALcloser2Model[n] = sProdukte[i][dki_PRODUKT]
						ELSE
						IF sProdukte[i][dki_PRODUKT] # VALcloser2Model[n] THEN ! identisch mit letztem Eintrag?
							n = n+1 : VALcloser2Model[n] = sProdukte[i][dki_PRODUKT]
							ENDIF
						ENDIF
					ENDIF

				ENDIF

			NEXT i

		! Der derzeit eingestellte nicht in der Auswahlliste?
		IF selectedS2 < 1 OR bs_closer_model2 = "-" THEN
			IF n > 0 THEN

				! Es gibt eine Auswahlliste. Erst besten suchen:
				FOR j = 1 TO n
					FOR i = 1 TO VARDIM1(sProdukte)
						IF VALcloser2Model[j] = sProdukte[i][dki_PRODUKT] THEN
							! Element gefunden
							IF selectedS2 = 0 THEN selectedS2 = -i
							! Entspricht Element auch den Anforderungen?
							FOR k = 1 TO VARDIM1(UIcloser2ModelText)
								IF sProdukte[i][dki_PRODUKT] = UIcloser2ModelText[k] THEN
									! Element gefunden
									selectedS2 = -i
									k = 999 : i = 999 : j = 999
									ENDIF
								NEXT k
							ENDIF
						NEXT i
					NEXT j

				ELSE

				! Es gibt keine Auswahlliste. 1. Element des Typs (als unpassend) aus Gesamtliste wählen
				selectedS2 = -2
				FOR i=1 TO VARDIM1(sProdukte)
					IF  iProdukte[i][dki_SEITE] < 2 AND \
						( (((sProdukte[i][dki_ART] = "G" OR sProdukte[i][dki_ART] = "X") AND bs_slider_system = "G" ) AND bs_closer_type = "OTS" ) OR \
						((sProdukte[i][dki_ART] = "S" AND bs_slider_system = "S" ) AND bs_closer_type = "OTS" ) OR \
						(sProdukte[i][dki_ART] = "I" AND bs_closer_type = "ITS" ) OR \
						(sProdukte[i][dki_ART] = "B" AND bs_closer_type = "BTS" )) THEN
						! Element gefunden
						selectedS2 = -i
						n = 1 : VALcloser2Model[n] = sProdukte[i][dki_PRODUKT]
						sts = 1 : sts3 = 0 : k = 1 : GOSUB "addSystem2UI2"
						i = 999
						ENDIF
					NEXT i			
				ENDIF

			ENDIF

		! Daten des gewälten nochmal lesen
		i = ABS(selectedS2) : IF i > 0 THEN GOSUB "readBody2"

		! ------------------------------------------------------------- Check auf Grundanforderungen

		IF curInfo AND ( bs_ac_closing = "GS" AND bs_closer_fix2 # "E" AND bs_closer_fix2 # "B" ) THEN
			errorI = errorI+1 : errorQ[errorI] = "SF: Schließer passt nicht zu Funktionsanforderungen."
			ENDIF

		ENDIF

	IF bs_closer2 = 7 THEN  ! -> Schließer wie auf Gangflügel

		! ----------------------------------------------------------------- ... nicht individuell (nur 1 Typ)

		insert = 0 : infoE = ""
		sts = 0 : sts2 = 0 : sts3 = 0 ! Wenn sts wahr, dann Fehler

		FOR i=1 TO VARDIM1(sProdukte)
			IF bs_closer_model = sProdukte[i][dki_PRODUKT] THEN
				IF einszwei = 2 AND iProdukte[i][dki_SEITE] = 2 THEN
					! Gegenstück zu GF-Variante, also SF-Variante gefunden
					insert = 2
					ELSE
					! Wahrscheinlich GF-Variante gefunden
					insert = 1
					ENDIF
				ENDIF
			IF insert AND NOT( selectedS2 > 0 AND insert = 1 ) THEN  !   ! (selectedS2 > 0) - insert
				! Produkt in Liste aufnehmen
				k = k+1 : sts = 0 : GOSUB "addSystem2UI2"
				n = n+1 : VALcloser2Model[n] = sProdukte[i][dki_PRODUKT]
				! Wenn es das "Gegenstück" ist, dann Ende der Liste
				IF insert = 2 THEN
					GOSUB "setBody2"
					i = 999
					ELSE
					GOSUB "setBody2"
					insert = 0
					ENDIF
				ELSE
				insert = 0
				ENDIF
			NEXT i

		! i = ABS(selectedS2) : IF i > 0 THEN GOSUB "readBody2"


		IF selectedS2 < 1 THEN ! -> keinen gefunden
			k = 1
			UIcloser2ModelPic[k]  = 0
			UIcloser2ModelVal[k]  = "-"
			UIcloser2ModelText[k] = "Systemeinheit mit GF"   !+ sProdukte[i][dki_PRODUKT]
			n = 1
			VALcloser2Model[n] = "-"
			ELSE
			ENDIF

		ENDIF

	IF bs_closer2 < 2 THEN  ! kein Schließer auf SF
		! GOSUB "copy2nd"
		ENDIF

	ENDIF

! ------------------------------------------------------------- Check auf Grundanforderungen

IF bs_demand_FireResistance = 1 AND bs_closer_type = "-" AND NOT( automation = bs_door_leafs OR BITTEST(bs_closer2,0) + BITTEST(bs_closer2, 1) < bs_door_leafs ) THEN
	errorI = errorI+1
	IF automation = 1 AND bs_door_leafs = 2 THEN
		errorQ[errorI] = "Nach Brandschutzanforderung fehlt ein Türschließer auf dem Standflügel."
		ELSE
		errorQ[errorI] = "Nach Brandschutzanforderung fehlt ein Türschließer."
		ENDIF
	ENDIF


IF errorI < 1 THEN errorQ[1] = ""  ! Evt. zurückgenommene Fehler richtig löschen

! =============================================================================
! ENDE INITIALISIERUNG
! =============================================================================

IF macro_runtype = 256 THEN END errorQ  ! »»» Fehlermeldung

! ------------------------------------------------------------------------[ ... ]

GOTO "masterend"


! =============================================================================
! =============================================================================
!
! SUBROUTINES
!
! =============================================================================
! =============================================================================

! ------------------------------------------------------------------------ Produktauswahl in Auswahlliste setzen

"addSystem2UI":  ! »»» Gangflügel

	UIcloserModelPic[k] = 0
	UIcloserModelVal[k] = sProdukte[i][dki_PRODUKT]

	IF sts OR sts2 THEN
		UIcloserModelText[k] = "[ " + sProdukte[i][dki_PRODUKT] + " ]"
		ELSE
		UIcloserModelText[k] = sProdukte[i][dki_PRODUKT]
		IF sts3 THEN UIcloserModelText[k] = UIcloserModelText[k] + "  [!]" 
		ENDIF

	IF (sts OR sts2 OR (sts3 AND selectedS=i)) AND BITTEST(curInfo,0) THEN  ! Fehlermeldung setzen
		praefix = "GF: Schließer " : GOSUB "debuginfo" : errorI = errorI+1 : errorQ[errorI] = txt
		ENDIF

	RETURN

"addSystem2UI2":  ! »»» Standflügel

	UIcloser2ModelPic[k] = 0
	UIcloser2ModelVal[k] = sProdukte[i][dki_PRODUKT]

	IF sts OR sts2 THEN
		UIcloser2ModelText[k] = "[ " + sProdukte[i][dki_PRODUKT] + " ]"
		ELSE
		UIcloser2ModelText[k] = sProdukte[i][dki_PRODUKT]
		IF sts3 THEN UIcloser2ModelText[k] = UIcloser2ModelText[k] + "  [!]" 
		ENDIF

	IF (sts OR sts2 OR (sts3 AND selectedS2=i)) AND BITTEST(curInfo,1) THEN  ! Fehlermeldung setzen
		praefix = "SF: Schließer " : GOSUB "debuginfo" : errorI = errorI+1 : errorQ[errorI] = txt
		ENDIF

	RETURN


! ------------------------------------------------------------------------ selektierte [...]daten merken (GF)

"setBody":  ! »»» Gangflügel

	selectedS  	= i
	
"readBody":  ! »»» Gangflügel

	! IDENTIFIZIERUNG

	j = split(STRSUB( sProdukte[i][dki_TYP], 1, 3 ),"%n", serie)

	! ... [Typ2]:
	! 1 = N XEA,   2 = RF XEA,   4 = EMF XEA,   8 = EMR XEA,   16 = UVIBIS XEA,   32 = GSR XEA,   64 = GSR-EMF XEA,   128 = GSR-EMR XEA
	! 1 = N,   2 = RF,   4 = EMF,   8 = EMR,   16 = GSR,   32 = GSR RF,   64 = GSR-EMF 1,   128 = GSR-EMF 1G,   256 = GSR-EMF 2,   512 = GSR-EMR 1,   1024 = GSR-EMR 1G,   2048 = GSR-EMR 2
	! 1 = FL,   2  = FLR,   4 = FLR-K,   8 = FL GSR-EMR

	! EIGENSCHAFTEN AUSLESEN

	einszwei		 = iProdukte[i][dki_FLUEGEL]
	brandschutz  	 = eigenschaften[i][dki_BRANDSCHUTZ]
	barrierefreiheit = eigenschaften[i][dki_BARRIEREFREI]
	schliessfolge 	 = eigenschaften[i][dki_SCHLIESSFOLGE]
	daempfung  	 	 = eigenschaften[i][dki_DAEMPFUNG]
	verzoegerung	 = sProdukte[i][dki_VERZOEGERUNG]
	rauchmelder	 	 = iProdukte[i][dki_RAUCHMELDER]
	feststellung	 = sProdukte[i][dki_FESTSTELLUNG]

	! EIGENSCHAFTEN ERMITTELN

	! Schließkraft: Bitnummer + 1 = EN-Klasse
	minkraft = 0 : maxKraft = 0
	FOR j=0 TO 7
		IF minkraft < 1 AND BITTEST(iProdukte[i][dki_EN], j) THEN minkraft = j+1
		IF minkraft > 0 AND BITTEST(iProdukte[i][dki_EN], j) THEN maxKraft = j+1
		NEXT j

	! Türbreiten nach Schließkraft  (Bitnummer + 1 = EN-Klasse)

	IF maxKraft = 7 THEN
		maxTB = 1600 / 1000
		ELSE
		IF maxKraft = 6 THEN
			maxTB = 1400 / 1000
			ELSE
			IF maxKraft = 5 THEN
				maxTB = 1250 / 1000
				ELSE
				IF maxKraft = 4 THEN
					maxTB = 1100 / 1000
					ELSE  ! maxKraft = 3
					maxTB = 950 / 1000
					ENDIF
				ENDIF
			ENDIF
		ENDIF

	! Montagevarianten Schließer: 
	! Horizontal | Vertikal - montageTYP = MTx  =  montageart = 2 ^ (MTx -1)
	! OTS:    BS | T - T1 = 1     BGS | S - T2 = 2     BS  | S - T3 = 4     BGS | T - T4 = 8
	! ITS:    M  | T - T6 = 32    M   | K - T7 = 64
	! BTS:    BS | B - T8 = 128   M   | B - T9 = 256
	IF BITTEST( iProdukte[i][dki_MONTAGE], montageOTS - 1 ) THEN
		! dann wie eingestellt
		montageTYP = montageOTS
		ELSE
		! erste funktionierende Position
		FOR j=0 TO 8
			IF BITTEST(iProdukte[i][dki_MONTAGE], j) THEN
				montageTYP = j+1
				j = 9
				ENDIF
			NEXT j
		ENDIF
	montageart = 2 ^ (montageTYP - 1)

	! Systemdedingte Werte (Abmessungen Körper) ...
	kx = abmessungK[i][dki_kx] / 1000
	ky = abmessungK[i][dki_ky] / 1000
	kz = abmessungK[i][dki_kz] / 1000

	! GEOMETRIE / POSITION AUSLESEN

	! Lage abhängig von Montagevariante
	IF montageTYP = 1 OR montageTYP = 6 THEN  ! 1: Türblatt / BS oder ITS
		j = dki_xT_MT1
		ELSE
		IF montageTYP = 3 OR montageTYP = 7 OR montageTYP = 8 THEN  ! 3: Sturz / BS oder ITS
			j = dki_xT_MT3
			ELSE
			IF montageTYP = 2 THEN  ! 2: ...
				j = dki_xT_MT2
				ELSE  ! 4/5: Türblatt / BGS
				j = dki_xT_MT4
				ENDIF
			ENDIF
		ENDIF
		
	! Lage Körper
	xT	= dimensionK[i][j] / 1000
	zT	= dimensionK[i][j+1] / 1000
		
	! Drehachse am Körper
	xD	= abmessungG[i][dki_xkD] / 1000 + xT
	yD	= abmessungG[i][dki_ykD] / 1000 ! + yT
	
	! Lage Schiene
	xG	= dimensionG[i][j] / 1000
	zG	= dimensionG[i][j+1] / 1000

	! Abmessungen Schiene / Mechanik
	IF schere THEN ! Gestänge-TS

		! Ankerschuh Spannschloss Schere - Abmessungen
		sx	= 0.058
		sy	= 0.0195
		sz	= 0.016

		! Drehpunkt an Halteschuh
		xL	= xG
		yL	= 0.012

		! Positionierung Ankerschuh
		dsx = 0.021
		dsz = sz/2

		! Bei Scherengestänge kommt über sxyz die Gestängeabmessung
		tG	= abmessungG[i][dki_sy] / 1000
		hG	= abmessungG[i][dki_sz] / 1000

		! lG	= abmessungG[i][dki_sx] / 1000
		! xH		= abmessungG[i][dki_xH] / 1000

		! Spannschloss in Grundstellung senkrecht zu Tür!
		GOSUB "calcBodyAncor0" ! Position des Anker- und Drehpunktes bei 0°
		r = abmessungG[i][dki_xH] / 1000 ! Standardlänge Hebel
		GOSUB "MontageS"
		IF h > 0*0.305-tlr AND h < 0.425+tlr THEN
			lG = h : xH = r
			ELSE
			r = 320 / 1000
			GOSUB "MontageS"
			lG = h : xH = r
			ENDIF
		! Breite/ Höhe Hebel
		yH = 0.022 : zH = 0.005

		! Gestänge / Hebel + Start+Laufweg in der Schiene
		LaBS	= abmessungG[i][dki_LaBS] / 1000
		LA 		= xD + xH - xG
			
		ENDIF

	IF NOT(schere) THEN  ! Bei Gleitschiene-TS

		dsx = 0 : dsz = 0 

		! Gleitschiene - Abmessungen
		sx	= abmessungG[i][dki_sx] / 1000
		sy	= abmessungG[i][dki_sy] / 1000
		sz	= abmessungG[i][dki_sz] / 1000
		IF sx > 9 THEN
			sx = ac_egress_width + 2 * HingeEgressDistance - 2 * xG
			ENDIF

		! Gestänge / Hebel + Start+Laufweg in der Schiene
		xH		= abmessungG[i][dki_xH] / 1000
		LaBS	= abmessungG[i][dki_LaBS] / 1000
		LA 		= xD + xH - xG

		IF bs_closer_type # "BTS" THEN
			yH = 0.02 : zH = 0.005
			ENDIF
			
		! Gleit-/Laufachse
		xL	= xG + LaBS   ! xG + 0.025
		yL	= abmessungG[i][dki_yL] / 1000

		ENDIF

	! Positionierung ITS errechnen, da variable Position möglich
	IF bs_closer_type = "ITS" THEN
		! Offset Körper+Schiene
		IF stumpf OR (gs_leaf_thk - bs_leaf_overhang < ky) THEN yT = -(gs_leaf_thk - ky) / 2 ELSE yT = - bs_leaf_overhang
		yG	= MIN( 0, -(gs_vt - sy) / 2 - NOT(stumpf) * bs_leaf_overhang)
		! Offet Achsen der Drehpunkte bzw. Gleitachse
		yD	= - ky / 2
		yL	= - sy / 2
		ENDIF

	! Positionierung BTS bestimmen
	IF bs_closer_type = "BTS" THEN
		! Offset Körper
		yT = -3/1000

		! Abdeckung
		abx  = 0.358
		aby  = 0.105
		dabx = -0.003
		daby = (ky-aby)/2
		ENDIF

	RETURN


! ------------------------------------------------------------------------ selektierte [...]daten merken (SF)

"setBody2":  ! »»» Standflügel

	selectedS2	= i
	
"readBody2":  ! »»» Standflügel

	! IDENTIFIZIERUNG

	j = split(STRSUB( sProdukte[i][dki_TYP], 1, 3 ),"%n", serie2)

	! ... [Typ2]:
	! 1 = N XEA,   2 = RF XEA,   4 = EMF XEA,   8 = EMR XEA,   16 = UVIBIS XEA,   32 = GSR XEA,   64 = GSR-EMF XEA,   128 = GSR-EMR XEA
	! 1 = N,   2 = RF,   4 = EMF,   8 = EMR,   16 = GSR,   32 = GSR RF,   64 = GSR-EMF 1,   128 = GSR-EMF 1G,   256 = GSR-EMF 2,   512 = GSR-EMR 1,   1024 = GSR-EMR 1G,   2048 = GSR-EMR 2
	! 1 = FL,   2  = FLR,   4 = FLR-K,   8 = FL GSR-EMR

	! EIGENSCHAFTEN AUSLESEN

	brandschutz2	 = eigenschaften[i][dki_BRANDSCHUTZ]
	barrierefreiheit2 = eigenschaften[i][dki_BARRIEREFREI]
	daempfung2 	 	 = eigenschaften[i][dki_DAEMPFUNG]
	verzoegerung2	 = sProdukte[i][dki_VERZOEGERUNG]
	rauchmelder2	 = iProdukte[i][dki_RAUCHMELDER]
	feststellung2	 = sProdukte[i][dki_FESTSTELLUNG]

	! EIGENSCHAFTEN ERMITTELN

	! Schließkraft : Bitnummer + 1 = EN-Klasse
	minkraft2 = 0 : maxKraft2 = 0
	FOR j=0 TO 7
		IF minkraft2 < 1 AND BITTEST(iProdukte[i][dki_EN], j) THEN minkraft2 = j+1
		IF minkraft2 > 0 AND BITTEST(iProdukte[i][dki_EN], j) THEN maxKraft2 = j+1
		NEXT j

	! Türbreiten nach Schließkraft  (Bitnummer + 1 = EN-Klasse)

	IF maxKraft2 = 7 THEN
		maxTB2 = 1600 / 1000
		ELSE
		IF maxKraft2 = 6 THEN
			maxTB2 = 1400 / 1000
			ELSE
			IF maxKraft2 = 5 THEN
				maxTB2 = 1250 / 1000
				ELSE
				IF maxKraft2 = 4 THEN
					maxTB2 = 1100 / 1000
					ELSE  ! maxKraft2 = 3
					maxTB2 = 950 / 1000
					ENDIF
				ENDIF
			ENDIF
		ENDIF

	! Montagevarianten Schließer: 
	! Horizontal | Vertikal - montageTYP = MTx  =  montageart = 2 ^ (MTx -1)
	! OTS:    BS | T - T1 = 1     BGS | S - T2 = 2     BS  | S - T3 = 4     BGS | T - T4 = 8
	! ITS:    M  | T - T6 = 32    M   | K - T7 = 64
	! BTS:    BS | B - T8 = 128   M   | B - T9 = 256
	IF BITTEST( iProdukte[i][dki_MONTAGE], montageOTS - 1 ) THEN
		! dann wie eingestellt
		montageTYP2 = montageOTS
		ELSE
		! erste funktionierende Position
		FOR j=0 TO 8
			IF BITTEST(iProdukte[i][dki_MONTAGE], j) THEN
				montageTYP2 = j+1
				j = 9
				ENDIF
			NEXT j
		ENDIF
	montageart2 = 2 ^ (montageTYP2 - 1)

	! Systemdedingte Werte (Abmessungen Körper) ...
	kx2 = abmessungK[i][dki_kx] / 1000
	ky2 = abmessungK[i][dki_ky] / 1000
	kz2 = abmessungK[i][dki_kz] / 1000

	! #### GEOMETRIE / POSITION AUSLESEN

	! Lage abhängig von Montagevariante
	IF montageTYP2 = 1 OR montageTYP2 = 6 THEN  ! 1: Türblatt / BS oder ITS
		j = dki_xT_MT1
		ELSE
		IF montageTYP2 = 3 OR montageTYP = 7 OR montageTYP2 = 8 THEN  ! 3: Sturz / BS oder ITS
			j = dki_xT_MT3
			ELSE
			IF montageTYP2 = 2 THEN  ! 2: ...
				j = dki_xT_MT2
				ELSE  ! 4/5: Türblatt / BGS
				j = dki_xT_MT4
				ENDIF
			ENDIF
		ENDIF
		
	! Lage Körper
	xT2	= dimensionK[i][j] / 1000
	zT2	= dimensionK[i][j+1] / 1000
		
	! Drehachse am Körper
	xD2	= abmessungG[i][dki_xkD] / 1000 + xT2
	yD2	= abmessungG[i][dki_ykD] / 1000 ! + yT2

	! Lage Schiene
	xG2	= dimensionG[i][j] / 1000
	zG2	= dimensionG[i][j+1] / 1000

	! Abmessungen Schiene / Mechanik
	IF schere THEN ! Bei Gestänge-TS

		! Ankerschuh Spannschloss Schere - Abmessungen
		sx2	= 0.058
		sy2	= 0.0195
		sz2	= 0.016

		! Drehpunkt an Halteschuh
		xL2	= xG2
		yL2	= 0.012

		! Positionierung Ankerschuh
		dsx2 = 0.021
		dsz2 = sz2/2

		! Bei Scherengestänge kommt über sxyz die Gestängeabmessung
		tG2	= abmessungG[i][dki_sy] / 1000
		hG2	= abmessungG[i][dki_sz] / 1000

		! lG2	= abmessungG[i][dki_sx] / 1000
		! xH		= abmessungG[i][dki_xH] / 1000

		! Spannschloss in Grundstellung senkrecht zu Tür!
		GOSUB "calcBodyAncor0" ! Position des Anker- und Drehpunktes bei 0°
		r = abmessungG[i][dki_xH] / 1000 ! Standardlänge Hebel
		GOSUB "MontageS"
		IF h > 0*0.305-tlr AND h < 0.425+tlr THEN
			lG2 = h : xH2 = r
			ELSE
			r = 320 / 1000
			GOSUB "MontageS"
			lG2 = h : xH2 = r
			ENDIF
		! Breite/ Höhe Hebel
		yH2 = 0.022 : zH2 = 0.005

		! Gestänge / Hebel + Start+Laufweg in der Schiene
		LaBS2	= abmessungG[i][dki_LaBS] / 1000
		LA2 		= xD2 + xH2 - xG2

		ENDIF

	IF NOT(schere) THEN ! Bei Gleitschiene-TS

		dsx2 = 0 : dsz2 = 0

		! Gleitschiene - Abmessungen
		IF insert = 2 THEN
			sx  = sx + xG - xG2
			sx2 = sx : sy2 = sy : sz2 = sz
			ENDIF
		IF insert # 2 THEN
			sx2	= abmessungG[i][dki_sx] / 1000
			sy2	= abmessungG[i][dki_sy] / 1000
			sz2	= abmessungG[i][dki_sz] / 1000
			IF sx2 > 9 THEN
				sx2 = ac_egress_width + 2 * HingeEgressDistance - 2 * xG2
				ENDIF
			ENDIF

		! Gestänge / Hebel + Start+Laufweg in der Schiene
		xH2		= abmessungG[i][dki_xH] / 1000
		LaBS2	= abmessungG[i][dki_LaBS] / 1000
		LA2		= xD2 + xH2 - xG2
			
		IF bs_closer_type # "BTS" THEN
			yH2 = 0.02 : zH2 = 0.005
			ENDIF
			
		! Gleit-/Laufachse
		xL2	= xG2 + LaBS2   ! xG + 0.025
		yL2	= abmessungG[i][dki_yL] / 1000

		ENDIF


	! Positionierung ITS errechnen, da variable Position MÖGLICH
	IF bs_closer_type = "ITS" THEN
		! Offset Körper+Schiene
		IF stumpf OR (gs_leaf_thk - bs_leaf_overhang < ky2) THEN yT2 = -(gs_leaf_thk - ky2) / 2 ELSE yT2 = - bs_leaf_overhang
		yG2	= MIN( 0, -(gs_vt - sy2) / 2 - NOT(stumpf) * bs_leaf_overhang)
		! Offet Achsen der Drehpunkte bzw. Gleitachse
		yD2	= - ky2 / 2
		yL2	= - sy2 / 2
		ENDIF

	! Positionierung BTS bestimmen
	IF bs_closer_type = "BTS" THEN
		! Offset Körper
		yT2 = -3/1000

		! Abdeckung
		abx2  = 0.358
		aby2  = 0.105
		abz2  = 0.	
		dabx2 = -0.003
		daby2 = (ky-aby)/2
		ENDIF

	RETURN

	RETURN


! ------------------------------------------------------------------------ Plausibilitäten

"ckeck4fit":  ! »»» Gangflügel

	! Türblattabmessungen
	IF ac_leaf_width > maxTB + tlr AND maxTB > tlr THEN sts2=BITSET(sts2, 2)

	IF bs_closer_type = "ITS" THEN
		! Passt der Körper ins Türblatt?
		IF  ( montageTYP = 6 AND ( NOT(stumpf) * (gs_leaf_thk - bs_leaf_overhang < ky + 0.005) OR stumpf * (gs_leaf_thk < ky + 0.01) ) ) OR \
			( montageTYP = 7 AND ( NOT(stumpf) * (gs_leaf_thk - bs_leaf_overhang < sy + 0.005) OR stumpf * (gs_leaf_thk < sy + 0.01) ) ) THEN  sts2=BITSET(sts2, 5)
		! Und die Schiene in den Falz?
		IF  ( montageTYP = 6 AND ( gs_vt < sy + 0.005 ) ) OR \
			( montageTYP = 7 AND ( gs_vt < ky + 0.005 ) ) THEN  sts2=BITSET(sts2, 6)
		ENDIF

	! Schließkraft
	IF bs_closer_force > maxKraft THEN sts=BITSET(sts, 3)

	! PRÜFEN AUCH MIT BERECHNETEN EIGENSCHAFTEN

	! [X] -> Türblattabmessungen (Bandseite)
	IF bs_closer_orientation = "BS" THEN
		! [X] -> Verfügbare Breite
		IF bs_closer_position = "T" THEN ! Körper zu breit?
			IF HingePanelGap + ac_leaf_width < xT + kx THEN sts2=BITSET(sts2, 3)
			ENDIF
		IF bs_closer_position = "S" AND sx < 9 THEN ! Schiene zu breit?
			! Verfügbare Breite
			IF HingePanelGap + ac_leaf_width < xG + sx THEN sts2=BITSET(sts2, 3)
			ENDIF
		ENDIF

	! [X] -> Abmessungen im lichten Durchgang bzw. bis Türblattteilung (Bandgegenseite)
	IF bs_closer_orientation = "GS" THEN
		! Verfügbarerr Platz in lichtem Zargendurchgang
		IF bs_door_leafs = 2 THEN
			s = HingePanelGap + ac_leaf_width - (bs_FrameRebate_width - ac_egress_width)/2
			ELSE
			! s = HingeEgressDistance + ac_egress_width
			s = HingePanelGap + ac_leaf_width/2 + ac_egress_width/2
			ENDIF
		! Verfügbare Breite prüfen
		IF bs_closer_position = "T" THEN ! Körper zu breit?
			IF s < xT + kx THEN sts2=BITSET(sts2, 3)
			ENDIF
		! Höhe des Zargenspiegels
		IF bs_closer_position = "S" AND sx < 9 THEN ! Schiene zu breit?
			IF s < xG + sx THEN sts2=BITSET(sts2, 3)
			ENDIF
		ENDIF

	! [X] -> Zargenabmessungen (Bandseite)...
	s = HingeEgressDistance + ac_egress_width   ! Abstand Bandachse zu Außenkante Zarge Schlosseite
	IF ac_OpeningSide = "L" THEN  ! Verfügbarer Platz ...
		! ... rechts
		IF gs_sidelight_right THEN
			IF dk_sidelight_transom1 THEN
				IF dk_frametype = "UZ" OR  dk_frametype = "EZ" THEN
					s = s + gs_sidelight_width_right + bs_spiegel_br_bs - (gs_frame_width_right - gs_vb)
					ELSE
					s = s + gs_sidelight_width_right
					ENDIF
				ELSE
				s = s + gs_frame_width_right_2
				ENDIF
			ELSE
			IF dk_frametype = "UZ" OR  dk_frametype = "EZ" THEN
				s = s + gs_frame_width_right + bs_spiegel_br_bs - (gs_frame_width_right - gs_vb)
				ELSE
				s = s + gs_frame_width_right
				ENDIF
			ENDIF
		ELSE
		! ... links
		IF gs_sidelight_left  THEN
			IF dk_sidelight_transom2 THEN
				IF dk_frametype = "UZ" OR  dk_frametype = "EZ" THEN
					s = s + gs_sidelight_width_left + bs_spiegel_br_bs - (gs_frame_width_left - gs_vb)
					ELSE
					s = s + gs_sidelight_width_left
					ENDIF
				ELSE
				s = s + gs_frame_width_left_2
				ENDIF
			ELSE
			IF dk_frametype = "UZ" OR  dk_frametype = "EZ" THEN
				s = s + gs_frame_width_left + bs_spiegel_br_bs - (gs_frame_width_left - gs_vb)
				ELSE
				s = s + gs_frame_width_left
				ENDIF
			ENDIF
		ENDIF
	! ... Prüfung
	IF bs_closer_position = "S" THEN ! Körper passt nicht auf Zarge?
		IF s < xT + kx THEN sts2=BITSET(sts2, 4)
		ENDIF
	IF bs_closer_position = "T" AND sx < 9 THEN ! Schiene passt nicht auf Zarge?
		IF s < (xG + sx) THEN sts2=BITSET(sts2, 4)	
		ENDIF

	! [X] -> Zargenabmessungen (Bandgegenseite)...
		! ----> noch ungeprüft

	! [Z] -> Zargenspiegel-/Kämpfer-/Oberblendebreiten (Bandseite)
	IF bs_closer_orientation = "BS" THEN
		! Schiene zu hoch?
		IF bs_closer_position = "T" THEN
			IF zG + sz > facingLintelBS + tlr THEN
				IF frame2wallSurfaceBS < tlr OR oberLichtBlende THEN
					sts3 = BITSET(sts3, 1)
					infoE = str( 1000*(zG+sz-facingLintelBS), 3, 0) + " mm"
					! infoE = str( 1000*(facingLintelBS), 3, 0) + " mm Spiegel"
					ELSE
					! Zarge eingezogen ? -> dann auf Wand
					IF facingLintelBS > zG THEN
						sts3 = BITSET(sts3, 3)
						infoE = str( 1000*(ac_reveal_height - (ac_leaf_height + gapHeightUnderPanel) - zG), 3, 0) + " mm"
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		! Körper zu hoch?
		IF bs_closer_position = "S" THEN
			IF zT + kz > facingLintelBS + tlr THEN
				IF frame2wallSurfaceBS < tlr OR oberLichtBlende THEN
					sts3=BITSET(sts3, 0)
					infoE = str( 1000*(zT+kz-facingLintelBS), 3, 0) + " mm"
					! infoE = str( 1000*(facingLintelBS), 3, 0) + " mm Spiegel"
					ELSE
					! Zarge eingezogen ? -> dann auf Wand
					IF facingLintelBS > zT THEN
						sts3 = BITSET(sts3, 2)
						infoE = str( 1000*(ac_reveal_height - (ac_leaf_height + gapHeightUnderPanel) - zT), 3, 0) + " mm"
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		ENDIF

	! [Z] -> Zargenspiegel-/Kämpfer-/Oberblendebreiten (Bandgegenseite)
	IF bs_closer_orientation = "GS" THEN
		! Schiene zu hoch?
		IF bs_closer_position = "T" THEN
			IF zG + sz > facingLintelBGS + tlr THEN
				sts3 = BITSET(sts3, 1)
				infoE = str( 1000*(zG+sz-facingLintelBGS), 3, 0) + " mm"
				! infoE = str( 1000*(facingLintelBGS), 3, 0) + " mm Spiegel"
				ENDIF
			ENDIF
		! Körper zu hoch?
		IF bs_closer_position = "S" THEN
			IF zT + kz > facingLintelBGS + tlr THEN
				sts3=BITSET(sts3, 0)
				infoE = str( 1000*(zT+kz-facingLintelBGS), 3, 0) + " mm"
				! infoE = str( 1000*(facingLintelBGS), 3, 0) + " mm Spiegel"
				ENDIF
			ENDIF
		ENDIF

	! Montageposition
	IF NOT( BITTEST(iProdukte[i][dki_MONTAGE], montageOTS - 1)) THEN sts2=BITSET(sts2, 1)

	! Prüfung Abstände Montageebenen
	FOR j = 1 TO VARDIM1(maxDistanz)
		IF maxDistanz[j][1] = serie AND maxDistanz[j][2] = montageTYP AND maxDistanz[j][3] > tlr THEN
			s = 0
			IF (montageTYP = 1 OR montageTYP = 3) THEN s = offsetHingePanelSurfaceBS + bs_ancor_hinge_Y
			IF (montageTYP = 2 OR montageTYP = 4) THEN s = (offsetFrameSurfaceBGS + bs_ancor_hinge_Y) - (gs_leaf_thk - offsetHingePanelSurfaceBS)
			IF  maxDistanz[j][3]/1000+tlr < s THEN
				sts3=BITSET(sts3, 4)
				IF montageTYP = 4 AND maxDistanz[j+1][3] > tlr THEN infoE = " ohne Monatgewinkel um " ELSE infoE = " um "
				infoE = infoE + str("%.0", 1000*s - maxDistanz[j][3]) + " mm"
				ENDIF
			j = 999
			ENDIF
		NEXT j
	
	RETURN
	
"ckeck4fit2":  ! »»» Standflügel

	! Türblattabmessungen
	IF gs_SecondLeaf_w > maxTB2 + tlr AND maxTB2 > tlr THEN sts2=BITSET(sts2, 2)

	IF bs_closer_type = "ITS" THEN
		! Passt der Körper ins Türblatt?
		IF  ( montageTYP2 = 6 AND ( NOT(stumpf) * (gs_leaf_thk - bs_leaf_overhang < ky2 + 0.005) OR stumpf * (gs_leaf_thk < ky2 + 0.01) ) ) OR \
			( montageTYP2 = 7 AND ( NOT(stumpf) * (gs_leaf_thk - bs_leaf_overhang < sy2 + 0.005) OR stumpf * (gs_leaf_thk < sy2 + 0.01) ) ) THEN  sts2=BITSET(sts2, 5)
		! Und die Schiene in den Falz?
		IF  ( montageTYP2 = 6 AND ( gs_vt < sy2 + 0.005 ) ) OR \
			( montageTYP2 = 7 AND ( gs_vt < ky2 + 0.005 ) ) THEN  sts2=BITSET(sts2, 6)
		ENDIF

	! Schließkraft
	IF bs_closer_force2 > maxKraft2 THEN sts=BITSET(sts, 3)

	! PRÜFEN AUCH MIT BERECHNETEN EIGENSCHAFTEN

	! [X] -> Türblattabmessungen (Bandseite)
	IF bs_closer_orientation = "BS" THEN
		! [X] -> Verfügbare Breite
		IF bs_closer_position = "T" THEN ! Körper zu breit?
			IF HingePanelGap + gs_SecondLeaf_w < xT2 + kx2 THEN sts2=BITSET(sts2, 3)
			ENDIF
		IF bs_closer_position = "S" THEN ! Schiene zu breit?
			IF HingePanelGap + gs_SecondLeaf_w < xG2 + sx2 THEN sts2=BITSET(sts2, 3)
			ENDIF
		ENDIF

	! [X] -> Abmessungen bis Türblattteilung (Bandgegenseite)
	IF bs_closer_orientation = "GS" THEN
		! Verfügbarerr Platz in lichtem Zargendurchgang
		s = HingePanelGap + gs_SecondLeaf_w - (bs_FrameRebate_width - ac_egress_width)/2
		! Verfügbare Breite prüfen
		IF bs_closer_position = "T" THEN ! Körper zu breit?
			IF s < xT2 + kx2 THEN sts2=BITSET(sts2, 3)
			ENDIF
		! Höhe des Zargenspiegels
		IF bs_closer_position = "S" THEN ! Schiene zu breit?
			IF s < xG2 + sx2 THEN sts2=BITSET(sts2, 3)
			ENDIF
		ENDIF

	! [X] -> Zargenabmessungen (Bandseite)...
		! ----> noch ungeprüft, muss Schiene/Körper für den Gangflügel berücksichtigt werden.

	! [X] -> Zargenabmessungen (Bandgegenseite)...
		! ----> noch ungeprüft

	! [Z] -> Zargenspiegel-/Kämpfer-/Oberblendebreiten (Bandseite)
	IF bs_closer_orientation = "BS" THEN
		! Schiene zu hoch?
		IF bs_closer_position = "T" THEN
			IF zG2 + sz2 > facingLintelBS + tlr THEN
				IF frame2wallSurfaceBS < tlr OR oberLichtBlende THEN
					sts3 = BITSET(sts3, 1)
					infoE = str( 1000*(zG2+sz2-facingLintelBS), 3, 0) + " mm"
					ELSE
					! Zarge eingezogen ? -> dann auf Wand
					IF facingLintelBS > zG2 THEN
						sts3 = BITSET(sts3, 3)
						infoE = str( 1000*(ac_reveal_height - (ac_leaf_height + gapHeightUnderPanel) - zG2), 3, 0) + " mm"
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		! Körper zu hoch?
		IF bs_closer_position = "S" THEN
			IF zT2 + kz2 > facingLintelBS + tlr THEN
				IF frame2wallSurfaceBS < tlr OR oberLichtBlende THEN
					sts3=BITSET(sts3, 0)
					infoE = str( 1000*(zT2+kz2-facingLintelBS), 3, 0) + " mm"
					ELSE
					! Zarge eingezogen ? -> dann auf Wand
					IF facingLintelBS > zT2 THEN
						sts3 = BITSET(sts3, 2)
						infoE = str( 1000*(ac_reveal_height - (ac_leaf_height + gapHeightUnderPanel) - zT2), 3, 0) + " mm"
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		ENDIF

	! [Z] -> Zargenspiegel-/Kämpfer-/Oberblendebreiten (Bandgegenseite)
	IF bs_closer_orientation = "GS" THEN
		! Schiene zu hoch?
		IF bs_closer_position = "T" THEN
			IF zG2 + sz2 > facingLintelBGS + tlr THEN
				sts3 = BITSET(sts3, 1)
				infoE = str( 1000*(zG2+sz2-facingLintelBGS), 3, 0) + " mm"
				ENDIF
			ENDIF
		! Körper zu hoch?
		IF bs_closer_position = "S" THEN
			IF zT2 + kz2 > facingLintelBGS + tlr THEN
				sts3=BITSET(sts3, 0)
				infoE = str( 1000*(zT2+kz2-facingLintelBGS), 3, 0) + " mm"
				ENDIF
			ENDIF
		ENDIF

	! Montageposition
	IF NOT( BITTEST(iProdukte[i][dki_MONTAGE], montageOTS - 1)) THEN sts2=BITSET(sts2, 1)

	RETURN


! ------------------------------------------------------------------------ Partameterübertragung

"ResetKonstanten":
	! Identifizierung
	montageart = 0
	serie = 0 : XEA = 0
	! Eigenschaften
	brandschutz  	 = 0
	barrierefreiheit = 0
	schliessfolge 	 = 0
	daempfung  	 	 = 0
	verzoegerung 	 = "-"
	rauchmelder	 	 = 0
	feststellung	 = "-"
	! EN-Klasse
	minkraft = 0
	maxKraft = 0
	! Abmessungen Körper
	kx = 0
	kz = 0
	ky = 0		
	! Lage Körper
	xT	= 0
	yT	= 0
	zT	= 0
	! Lage Schiene
	xG	= 0
	yG	= 0
	zG	= 0
	! Abmessungen Schiene
	sx	= 0
	sy	= 0
	sz	= 0
	! Drehachse am Körper
	xD	= 0
	yD	= 0
	! Gestänge / Hebel + Start+Laufweg in der Schiene
	xH		= 0
	LaBS	= 0
	LA 		= 0
	! Gleit-/Laufachse
	xL	= 0
	yL	= 0
	! intern
	selectedS = 0
	einszwei = 0
	treffer = 0
	mv = 0
	maxTB = 0
	RETURN

"ResetKonstanten2":
	! Identifizierung
	montageart2	= 0
	serie2 = 0 : XEA2 = 0
	! Eigenschaften
	brandschutz2 	 = 0
	barrierefreiheit2= 0
	daempfung2	 	 = 0
	verzoegerung2	 = "-"
	rauchmelder2	 = 0
	feststellung2	 = "-"
	! EN-Klasse
	minkraft2 = 0
	maxKraft2 = 0
	! Abmessungen Körper
	kx2 = 0
	kz2 = 0
	ky2 = 0		
	! Lage Körper
	xT2	= 0
	yT2	= 0
	zT2	= 0
	! Lage Schiene
	xG2	= 0
	yG2	= 0
	zG2	= 0
	! Abmessungen Schiene
	sx2	= 0
	sy2	= 0
	sz2	= 0
	! Drehachse am Körper
	xD2	= 0
	yD2	= 0
	! Gestänge / Hebel + Start+Laufweg in der Schiene
	xH2		= 0
	LaBS2	= 0
	LA2		= 0
	! Gleit-/Laufachse
	xL2	= 0
	yL2	= 0
	! intern
	selectedS2 = 0
	treffer2 = 0
	maxTB2 = 0
	RETURN

"copyMain":
	! »»» Standflügel
	selectedS = selectedS2
	montageart 	= montageart2
	montageTYP 	= montageTYP2
	kx = kx2 : ky = ky2 : kz = kz2
	abx = abx2 : aby = aby2 : abz = abz2 : dabx = dabx2 : daby = daby2
	xT = xT2 : yT = yT2 : zT = zT2
	xD	= xD2 : yD	= yD2
	xL	= xL2 : yL	= yL2
	xG = xG2 : yG = yG2 : zG = zG2
	xH	= xH2 : yH = yH2 : zH = zH2
	LA	= LA2 : LaBS = LaBS2
	lG	= lG2 : tG	= tG2 : hG = hG2
	IF NOT(stand) OR (einszwei # 2) THEN
		sx  =  sx2 : sz  =  sz2 : sy = sy2
		dsx = dsx2 : dsz = dsz2
		ENDIF
	RETURN

"copy2nd":
	! Eigenschaften Standflügel wie Gangflügel
	selectedS2 = selectedS

	! Identifizierung
	serie2		= serie
	montageart2	= montageart
	! Eigenschaften
	brandschutz2 	 = brandschutz
	barrierefreiheit2= barrierefreiheit
	daempfung2	 	 = daempfung
	verzoegerung2	 = verzoegerung
	rauchmelder2	 = rauchmelder
	feststellung2	 = feststellung
	! EN-Klasse
	minkraft2 = minkraft
	maxKraft2 = maxKraft
	! Abmessungen Körper
	kx2 = kx
	kz2 = kz
	ky2 = ky	
	! Lage Körper
	xT2	= xT
	yT2	= yT
	zT2	= zT
	! Lage Schiene
	xG2	= xG
	yG2	= yG
	zG2	= zG
	! Abmessungen Schiene
	sx2	= sx
	sy2	= sy
	sz2	= sz
	! Drehachse am Körper
	xD2	= xD
	yD2	= yD
	! Gestänge / Hebel + Start+Laufweg in der Schiene
	xH2		= xH
	LaBS2	= LaBS
	LA2		= LA
	! Gleit-/Laufachse
	xL2	= xL
	yL2	= yL
	! User Interface
	k = 1
	UIcloser2ModelPic[k]  = 0
	UIcloser2ModelVal[k]  = "-"
	UIcloser2ModelText[k] = "Kein Schließer"   !+ sProdukte[i][dki_PRODUKT]
	n = 1
	VALcloser2Model[n] = "-"
	RETURN


! ------------------------------------------------------------------------ Berechnungen 2D/3D

! DAx,DAy  Drehpunkt am Körper
! APx,APy  Ankerpunkt, bei Schiene Position/Gleitpunkt in der Schienenachse
! xH  Hebellänge (1. am Körper in Drehachse und 2. entweder mit Spannschloss 
!     verbunden (250mm oder 320mm) oder in Schiene gleitend)
! lG  Länge des Spannschlosses (305-420mm oder 325-425mm) 


! #### SCHLIESSKÖRPER | Geometrie Mechanik ermitteln + Auf linke untere Ecke des Körpers bewegen

"calcBody":   ! »»» OTS Gleitschienen - Schließkörper

	IF montageTYP = 1 THEN ! 1: Türblatt / BS  [BITTEST(montageart, 0)]
		dis2lintel_closer = offsetHingePanelSurfaceBS
		IF GLOB_SCRIPT_TYPE = 2 THEN
			w = open_leaf : ROT2 w
			ADD2 xT, dis2lintel_closer
			n = 2
			ENDIF
		IF GLOB_SCRIPT_TYPE = 3 THEN
			w = open_leaf : ROTz w
			dk_ancor_closer = ac_leaf_height + gapHeightUnderPanel
			z = dk_ancor_closer - zT - kz : ADD xT, dis2lintel_closer, z
			n = 2
			ENDIF
		w = w : x = xD : y = dis2lintel_closer + yD : GOSUB "calcDAT"
		ELSE
		IF montageTYP = 3 THEN ! 3: Sturz / BS  [BITTEST(montageart, 2)]
			dis2lintel_closer = -bs_ancor_hinge_Y + MAX(0, frame2wallSurfaceBS) * (oberLichtBlende = 0) * (zT + kz > facingLintelBS + tlr) + bs_leaf_overhang * (oberLichtBlende = 2)
			IF GLOB_SCRIPT_TYPE = 2 THEN
				ADD2 xT, dis2lintel_closer
				n = 1
				ENDIF
			IF GLOB_SCRIPT_TYPE = 3 THEN
				dk_ancor_closer = ac_leaf_height + gapHeightUnderPanel
				z = dk_ancor_closer + zT : ADD xT, dis2lintel_closer,z
				n = 1
				ENDIF
			w = 0 : x = xD : y =  dis2lintel_closer + yD : GOSUB "calcDAT"
			ELSE
			IF montageTYP = 4 OR montageTYP = 5 THEN ! 4/5: Türblatt / BGS  [BITTEST(montageart, 3) OR BITTEST(montageart, 4)]
				IF GLOB_SCRIPT_TYPE = 2 THEN
					w = open_leaf : ROT2 w
					ADD2 xT, offsetHingePanelSurfaceBS - gs_leaf_thk
					MUL2 1, -1
					n = 3
					ENDIF
				IF GLOB_SCRIPT_TYPE = 3 THEN
					w = open_leaf : ROTz w
					IF frame2wallSurfaceBGS > tlr AND zG + sz > facingLintelBGS + tlr AND NOT(oberLichtBlende) THEN
						! Sturz vor Zarge und kein Platz auf Profil? -> dann unter Sturz
						dk_ancor_closer = ac_wallhole_height - (zG + sz)  ! ac_reveal_height
						ELSE
						dk_ancor_closer = ac_egress_height
						ENDIF
					z = dk_ancor_closer - zT - kz : ADD xT, offsetHingePanelSurfaceBS - gs_leaf_thk, z
					MULy -1
					n = 3
					ENDIF
				gespiegelt = 1 - gespiegelt
				w = w : x = xD : y = offsetHingePanelSurfaceBS - gs_leaf_thk - yD : GOSUB "calcDAT"
				ELSE  ! montageTYP = 2:  Sturz / BGS ...
				IF GLOB_SCRIPT_TYPE = 2 THEN
					ADD2 xT, -offsetFrameSurfaceBGS - bs_ancor_hinge_Y
					MUL2 1, -1
					n = 2
					ENDIF
				IF GLOB_SCRIPT_TYPE = 3 THEN
					IF frame2wallSurfaceBGS > tlr AND zT + kz > facingLintelBGS + tlr AND NOT(oberLichtBlende) THEN
						! Sturz vor Zarge und kein Platz auf Profil? -> dann unter Sturz
						dk_ancor_closer = ac_wallhole_height - (zT + kz)  ! ac_reveal_height
						ELSE
						dk_ancor_closer = ac_egress_height
						ENDIF
					z = dk_ancor_closer + zT : ADD xT, -offsetFrameSurfaceBGS - bs_ancor_hinge_Y, z
					MULy -1
					n = 2
					ENDIF
				gespiegelt = 1 - gespiegelt
				w = 0 : x = xD : y = -offsetFrameSurfaceBGS - bs_ancor_hinge_Y - yD : GOSUB "calcDAT"
				ENDIF
			ENDIF
		ENDIF

	DAx = x : DAy = y

	RETURN

"calcBodyITS":   ! »»» ITS - Schließkörper
	! z = ac_leaf_height - (1-stumpf) * (bs_leaf_oversize + dk_panel_folding_gap)
	! z = bs_FrameRebate_height 

	IF montageTYP = 6 THEN ! 6: Türblatt / integriert  [BITTEST(montageart, 5)]
		IF GLOB_SCRIPT_TYPE = 2 THEN
			w = open_leaf : ROT2 w
			ADD2 xT, offsetHingePanelSurfaceBS + yT - ky
			n = 2
			ENDIF
		IF GLOB_SCRIPT_TYPE = 3 THEN
			w = open_leaf : ROTz w
			dk_ancor_closer = ac_leaf_height + gapHeightUnderPanel - (1-stumpf) * bs_leaf_oversize
			z = dk_ancor_closer - zT - kz : ADD xT, offsetHingePanelSurfaceBS + yT - ky, z
			n = 2
			ENDIF
		w = w : x = xD : y = offsetHingePanelSurfaceBS + yT + yD : GOSUB "calcDAT"
		ELSE   ! 7: Sturz|Kämpfer / integriert  [BITTEST(montageart, 6)]
		IF GLOB_SCRIPT_TYPE = 2 THEN
			ADD2 xT, offsetHingePanelSurfaceBS + yT - ky
			n = 1
			ENDIF
		IF GLOB_SCRIPT_TYPE = 3 THEN
			dk_ancor_closer = ac_leaf_height + gapHeightUnderPanel
			z = dk_ancor_closer + zT : ADD xT, offsetHingePanelSurfaceBS + yT - ky, z
			n = 1
			ENDIF
		w = 0 : x = xD : y = offsetHingePanelSurfaceBS + yT + yD : GOSUB "calcDAT"
		ENDIF

	DAx = x : DAy = y

	RETURN

"calcBodyBTS":   ! »»» BTS - Schließkörper

	dk_ancor_closer = 0

	IF montageTYP = 8 THEN ! 8: Boden / Bandseite  [BITTEST(montageart, 7)]
		IF GLOB_SCRIPT_TYPE = 2 THEN
			ADD2 xT, -bs_ancor_hinge_Y + yT
			n = 1
			ENDIF
		IF GLOB_SCRIPT_TYPE = 3 THEN
			z = -kz : ADD xT, -bs_ancor_hinge_Y + yT, z
			n = 1
			ENDIF
		w = 0 : x = xD : y =  -bs_ancor_hinge_Y + yT + yD : GOSUB "calcDAT"
		ELSE   ! 9: Boden / achsial  [BITTEST(montageart, 8)]
		IF GLOB_SCRIPT_TYPE = 2 THEN
			ADD2 xT, -bs_ancor_hinge_Y + yT
			n = 1
			ENDIF
		IF GLOB_SCRIPT_TYPE = 3 THEN
			z = -kz : ADD xT, -bs_ancor_hinge_Y + yT, z
			n = 1
			ENDIF
		w = 0 : x = xD : y =  -bs_ancor_hinge_Y + yT + yD : GOSUB "calcDAT"
		ENDIF

	DAx = x : DAy = y

	RETURN


! #### ANKER+SCHIENE | Geometrie Mechanik ermitteln + Auf linke untere Ecke des Gegenstücks (Schiene, Schuh) bewegen

"calcAncorPoint":   ! »»» OTS Gleitschienen - Schiene

	w = 0  ! Drehung Schiene wenn auf Türblatt
	m = 0  ! Steigung des Winkels zum Zielpunkt (für Berechnung nach dem Return)

	IF montageTYP = 3 THEN ! 3: Türblatt / BS  [BITTEST(montageart, 2)]
		dis2lintel_closer = offsetHingePanelSurfaceBS
		IF GLOB_SCRIPT_TYPE = 2 THEN
			w = open_leaf : ROT2 w
			ADD2 xG, dis2lintel_closer
			n = 2
			ENDIF
		IF GLOB_SCRIPT_TYPE = 3 THEN
			w = open_leaf : ROTz w
			z = dk_ancor_closer - zG - sz + dsz : ADD xG, dis2lintel_closer, z
			zGE = z + sz - dsz + (zT + zG)/2   ! Höhenlage der Gleitachse
			n = 2
			ENDIF
		m = TAN(w) : x = xL : y = yL + dis2lintel_closer : GOSUB "calcDAT"
		ELSE
		IF montageTYP = 1 THEN ! 1: Sturz / BS  [BITTEST(montageart, 0)]
			dis2lintel_closer = -bs_ancor_hinge_Y + MAX(0, frame2wallSurfaceBS) * (oberLichtBlende = 0) * (zG + sz > facingLintelBS + tlr) + bs_leaf_overhang * (oberLichtBlende = 2)
			IF GLOB_SCRIPT_TYPE = 2 THEN
				ADD2 xG, dis2lintel_closer
				n = 1
				ENDIF
			IF GLOB_SCRIPT_TYPE = 3 THEN
				z = dk_ancor_closer + zG - dsz : ADD xG, dis2lintel_closer, z
				zGE = z + dsz - (zT + zG)/2   ! Höhenlage der Gleitachse
				n = 1
				ENDIF
			x = xL : y =  dis2lintel_closer + yL : GOSUB "calcDAT"
			ELSE
			IF montageTYP = 2 THEN ! 2: Türblatt / BGS  [BITTEST(montageart, 1)]
				IF GLOB_SCRIPT_TYPE = 2 THEN
					w = open_leaf : ROT2 w
					ADD2 xG, offsetHingePanelSurfaceBS - gs_leaf_thk
					MUL2 1,-1
					n = 3
					ENDIF
				IF GLOB_SCRIPT_TYPE = 3 THEN
					w = open_leaf : ROTz w
					z = dk_ancor_closer - zG - sz + dsz : ADD xG, offsetHingePanelSurfaceBS - gs_leaf_thk, z
					MULy -1
					zGE = z + sz - dsz + (zT + zG)/2   ! Höhenlage der Gleitachse
					n = 3
					ENDIF
				m = TAN(w) : x = xL : y = offsetHingePanelSurfaceBS - gs_leaf_thk - yL : GOSUB "calcDAT"
				ELSE  ! montageTYP = 4/5: Sturz / BGS ...
				IF GLOB_SCRIPT_TYPE = 2 THEN
					ADD2 xG, -offsetFrameSurfaceBGS - bs_ancor_hinge_Y
					MUL2 1, -1
					n = 2
					ENDIF
				IF GLOB_SCRIPT_TYPE = 3 THEN
					z = dk_ancor_closer + zG - dsz : ADD xG, -offsetFrameSurfaceBGS - bs_ancor_hinge_Y, z
					MULy -1
					zGE = z + dsz - (zT + zG)/2   ! Höhenlage der Gleitachse
					n = 2
					ENDIF
				x = xL : y = -offsetFrameSurfaceBGS - bs_ancor_hinge_Y - yL : GOSUB "calcDAT"
				ENDIF
			ENDIF
		ENDIF
		
	APx = x : APy = y

	RETURN

"calcAncorPointITS":   ! »»» ITS - Schiene


	m = 0  ! Steigung des Winkels zum Zielpunkt (für Berechnung nach dem Return)

	IF montageTYP = 7 THEN ! 7: Türblatt / integriert  [BITTEST(montageart, 6)]
		IF GLOB_SCRIPT_TYPE = 2 THEN
			w = open_leaf : ROT2 w
			ADD2 xG, offsetHingePanelSurfaceBS + yG - sy
			n = 2
			ENDIF
		IF GLOB_SCRIPT_TYPE = 3 THEN
			w = open_leaf : ROTz w
			z = dk_ancor_closer - zG - sz : ADD xG, offsetHingePanelSurfaceBS + yG - sy, z
			zGE = z + sz + (zT + zG)/2   ! Höhenlage der Gleitachse
			n = 2
			ENDIF
		w = w : m = TAN(w) : x = xL : y = offsetHingePanelSurfaceBS + yG + yL : GOSUB "calcDAT"
		ELSE   ! 6: Sturz|Kämpfer / integriert  [BITTEST(montageart, 5)]
		IF GLOB_SCRIPT_TYPE = 2 THEN
			ADD2 xG, offsetHingePanelSurfaceBS + yG - sy
			n = 1
			ENDIF
		IF GLOB_SCRIPT_TYPE = 3 THEN
			z = dk_ancor_closer + zG : ADD xG, offsetHingePanelSurfaceBS + yG - sy, z-tlr
			zGE = z - (zT + zG)/2   ! Höhenlage der Gleitachse
			n = 1
			ENDIF
		w = 0 : m = 0 : x = xL : y = offsetHingePanelSurfaceBS + yG + yL : GOSUB "calcDAT"
		ENDIF
		
	APx = x : APy = y

	RETURN

"calcBodyAncor0":   ! »»» Koordinaten Ankerpunkt und Drehachse Hebel bei 0° Öffnung ermitteln
	IF montageTYP = 1 THEN ! 1: Türblatt / BS  [BITTEST(montageart, 0)]
		DAx = xD : DAy = offsetHingePanelSurfaceBS + yD
		APx = xL : APy =  -bs_ancor_hinge_Y + yL
		ELSE
		IF montageTYP = 3 THEN ! 3: Sturz / BS  [BITTEST(montageart, 2)]
			DAx = xD : DAy =  -bs_ancor_hinge_Y + yD
			APx = xL : APy = yL + offsetHingePanelSurfaceBS
			ELSE
			IF montageTYP = 4 OR montageTYP = 5 THEN ! 4/5: Türblatt / BGS  [BITTEST(montageart, 3) OR BITTEST(montageart, 4)]
				DAx = xD : DAy = offsetHingePanelSurfaceBS - gs_leaf_thk - yD
				APx = xL : APy = -offsetFrameSurfaceBGS - bs_ancor_hinge_Y - yL
				ELSE  ! montageTYP = 2: ...
				DAx = xD : DAy = -offsetFrameSurfaceBGS - bs_ancor_hinge_Y - yD
				APx = xL : APy = offsetHingePanelSurfaceBS - gs_leaf_thk - yL
				ENDIF
			ENDIF
		ENDIF
	RETURN


! #### GESTÄNGE + GEOMETRIE | Berechnungsroutinen

"calcDAT":  ! x/y-Koordinate um Öffnungswinkel / um Bandachse (0/0) transformieren
	IF ABS(w) > tlr AND x>tlr THEN
		s = SGN(y)
		y = ABS(y)
		r = SQR(x^2 + y^2)
		w = w + s * ATN(y / x)
		x = r * COS(w)
		y = r * SIN(w)
		ENDIF
	RETURN

"MontageS":  ! Berechne Spannschlosslänge bei gegebener Hebellänge senkrecht zu Tür
	h = ABS( DAy - APy ) + SQR( r^2 - (APx - DAx)^2 )
	RETURN

"positionG":  ! Position in der Gleitschiene berechnen
	! https://quickmath.com/webMathematica3/quickmath/equations/solve/advanced.jsp
	!  #c=solve_advancedsolveequations&v1=%2528x-v%2529%255E2%2520%2B%2520%2528y-w%2529%255E2%2520%253D%2520r%255E2%250Ay%2520%253D%2520m%2520*%2520%2528x-s%2529%2520%2B%2520t&v2=x%250Ay%250A

	r = xH  ! wirksame Hebellänge
	x =	-DAy^2 + (2*m*DAx + 2*APy - 2*m*APx) * DAy - m^2*DAx^2 + (2*m^2*APx - 2*m*APy) * DAx - APy^2 + 2*m*APx*APy - m^2*APx^2 + (m^2 + 1) * r^2
	y =	-DAy^2 + 2*m*DAx*DAy + 2*APy*DAy - 2*m*APx*DAy - m^2*DAx^2 - 2*m*APy*DAx + 2*m^2*APx*DAx - APy^2 + 2*m*APx*APy - m^2*APx^2 + m^2*r^2 + r^2
	IF x > 0 AND y > 0 THEN
		IF open_leaf < 90+tlr OR ABS(m) < tlr THEN
			x =	 ( SQR(x) + m*DAy + DAx - m*APy + m^2*APx) / (m^2 + 1)
			y =	(  m * SQR(y) + m^2*DAy + m*DAx + APy - m*APx ) / (m^2 + 1)
			ELSE
			x =	-( SQR(x) - m*DAy - DAx + m*APy - m^2*APx) / (m^2 + 1)
			y =	( -m * SQR(y) + m^2*DAy + m*DAx + APy - m*APx ) / (m^2 + 1)
			ENDIF
		ELSE
		x = DAx
		y = DAy
		ENDIF

	RETURN

"positionS":  ! Verbindungspunkt Gestänge und Spannschloss berechnen
	
	IF montageTYP = 1 THEN

		! LÖSUNG A  --> In einer Formel aufgelöst ...
		! ----
		! Schnittpunktberechnung 2 Kreise (Spannschloss, Gestänge)
		! https://de.wikipedia.org/wiki/Schnittpunkt#Schnittpunkte_zweier_Kreise
		! -> Schnittpunkt eines Kreises mit Gerade durch die beiden Schnittpunkte:
		! https://quickmath.com/webMathematica3/quickmath/equations/solve/advanced.jsp
		!  #c=solve_advancedsolveequations&v1=%2528x-A%2529%255E2%2B%2528y-B%2529%255E2%253DS%255E2%250A2*x*%2528C-A%2529%2B2*y*%2528D-B%2529%253DS%255E2-A%255E2-B%255E2-H%255E2%2BC%255E2%2BD%255E2&v2=x%250Ay%250A
		! Equations nach x und y
		! A = DAx : B = DAy : S = xH
		! C = APx : D = APy : H = lG
		! (x-A)^2+(y-B)^2=S^2
		! 2*x*(C-A)+2*y*(D-B)=S^2-A^2-B^2-H^2+C^2+D^2

		TX1 = (2 * lG^2 + 2 * APy^2 - 4 * DAy * APy + 2 * APx^2 - 4 * DAx * APx + 2 * DAy^2 + 2 * DAx^2)  *  xH^2
		TX2 = (2 * APy^2 - 4 * DAy * APy + 2 * APx^2 - 4 * DAx * APx + 2 * DAy^2 + 2 * DAx^2)  *  lG^2
		TX3 = (-APx^2 + 4 * DAx * APx - 6 * DAy^2 - 2 * DAx^2)  *  APy^2
		TX4 = (4 * DAy * APx^2 - 8 * DAx * DAy * APx + 4 * DAy^3 + 4 * DAx^2 * DAy)  *  APy
		TX5 = -APx^4 + 4 * DAx * APx^3 + (-2 * DAy^2 - 6 * DAx^2)  *  APx^2 + (4 * DAx * DAy^2 + 4 * DAx^3)  *  APx - DAy^4 - 2 * DAx^2 * DAy^2 - DAx^4
		KX1 = (DAx - APx) * xH^2 + (APx - DAx) * lG^2 + (-APx - DAx) * APy^2 +  (2 * DAy * APx + 2 * DAx * DAy) * APy - APx^3 + DAx * APx^2 + (DAx^2 - DAy^2) * APx - DAx * DAy^2 - DAx^3
		! KX2 = (APx - DAx) * xH^2 + (DAx - APx) * lG^2 +  (APx + DAx) * APy^2 + (-2 * DAy * APx - 2 * DAx * DAy) * APy + APx^3 - DAx * APx^2 + (DAy^2 - DAx^2) * APx + DAx * DAy^2 + DAx^3

		TY1 = -xH^2 + 2 * lG * xH - lG^2 + APy^2 - 2 * DAy * APy + APx^2 - 2 * DAx * APx + DAy^2 + DAx^2
		TY2 =  xH^2 + 2 * lG * xH + lG^2 - APy^2 + 2 * DAy * APy - APx^2 + 2 * DAx * APx - DAy^2 - DAx^2
		KY1 = (APy - DAy) * xH^2 + (DAy - APy) * lG^2 + APy^3 - DAy * APy^2 +  (APx^2 - 2 * DAx * APx - DAy^2 + DAx^2) * APy + DAy * APx^2 - 2 * DAx * DAy * APx + DAy^3 + DAx^2 * DAy
		! KY2 = (DAy - APy) * xH^2 + (APy - DAy) * lG^2 - APy^3 + DAy * APy^2 + (-APx^2 + 2 * DAx * APx + DAy^2 - DAx^2) * APy - DAy * APx^2 + 2 * DAx * DAy * APx - DAy^3 - DAx^2 * DAy

		TN  = 2 * APy^2 - 4 * DAy * APy + 2 * APx^2 - 4 * DAx * APx + 2 * DAy^2 + 2 * DAx^2

		! ... 1. quadratische Lösung, Längen wie aus Rohdaten
		TX = -xH^4 + TX1 - lG^4 + TX2 - APy^4 + 4 * DAy * APy^3 + TX3 + TX4 + TX5
		IF TX > 0 AND TN # 0 AND TY1 > 0 AND TY2 > 0 THEN
			x = -( (APy-DAy)  *  SQR( TX ) + KX1 ) / TN
			y =  ( (APx-DAx)  *  SQR( TY1 )  *  SQR( TY2 ) + KY1 ) / TN
			ELSE
			x = 0 : y = 0
			ENDIF

		! ... 2. quadratische Lösung
		! TX = -xH^4 + TX1 - lG^4 + TX2 - APy^4 + 4 * DAy * APy^3 + TX3 + TX4 + TX5
		! IF TX > 0 AND TN # 0 AND TY1 > 0 AND TY2 > 0 THEN
		! 	x =  ( (APy-DAy)  *  SQR( TX ) + KX2 ) / TN
		! 	y = -( (APx-DAx)  *  SQR( TY1 ) * SQR( TY2 ) + KY2 ) / TN
		! 	ELSE
		! 	x = 0 : y = 0
		! 	ENDIF

		ELSE

		! LÖSUNG A  --> In einer Formel aufgelöst ...  (jedoch Kreise vertauscht)
		! ----

		! TX1 = (2 * xH^2 + 2 * DAy^2 - 4 * APy * DAy + 2 * DAx^2 - 4 * APx * DAx + 2 * APy^2 + 2 * APx^2)  *  lG^2
		! TX2 = (2 * DAy^2 - 4 * APy * DAy + 2 * DAx^2 - 4 * APx * DAx + 2 * APy^2 + 2 * APx^2)  *  xH^2
		! TX3 = (-DAx^2 + 4 * APx * DAx - 6 * APy^2 - 2 * APx^2)  *  DAy^2
		! TX4 = (4 * APy * DAx^2 - 8 * APx * APy * DAx + 4 * APy^3 + 4 * APx^2 * APy)  *  DAy
		! TX5 = -DAx^4 + 4 * APx * DAx^3 + (-2 * APy^2 - 6 * APx^2)  *  DAx^2 + (4 * APx * APy^2 + 4 * APx^3)  *  DAx - APy^4 - 2 * APx^2 * APy^2 - APx^4
		! KX1 = (APx - DAx) * lG^2 + (DAx - APx) * xH^2 + (-DAx - APx) * DAy^2 +  (2 * APy * DAx + 2 * APx * APy) * DAy - DAx^3 + APx * DAx^2 + (APx^2 - APy^2) * DAx - APx * APy^2 - APx^3
		! ! KX2 = (DAx - APx) * lG^2 + (APx - DAx) * xH^2 +  (DAx + APx) * DAy^2 + (-2 * APy * DAx - 2 * APx * APy) * DAy + DAx^3 - APx * DAx^2 + (APy^2 - APx^2) * DAx + APx * APy^2 + APx^3

		! TY1 = -lG^2 + 2 * xH * lG - xH^2 + DAy^2 - 2 * APy * DAy + DAx^2 - 2 * APx * DAx + APy^2 + APx^2
		! TY2 =  lG^2 + 2 * xH * lG + xH^2 - DAy^2 + 2 * APy * DAy - DAx^2 + 2 * APx * DAx - APy^2 - APx^2
		! KY1 = (DAy - APy) * lG^2 + (APy - DAy) * xH^2 + DAy^3 - APy * DAy^2 +  (DAx^2 - 2 * APx * DAx - APy^2 + APx^2) * DAy + APy * DAx^2 - 2 * APx * APy * DAx + APy^3 + APx^2 * APy
		! ! KY2 = (APy - DAy) * lG^2 + (DAy - APy) * xH^2 - DAy^3 + APy * DAy^2 + (-DAx^2 + 2 * APx * DAx + APy^2 - APx^2) * DAy - APy * DAx^2 + 2 * APx * APy * DAx - APy^3 - APx^2 * APy

		! TN  = 2 * DAy^2 - 4 * APy * DAy + 2 * DAx^2 - 4 * APx * DAx + 2 * APy^2 + 2 * APx^2

		! ! 1. quadratische Lösung, Längen wie aus RohAPten
		! TX = -lG^4 + TX1 - xH^4 + TX2 - DAy^4 + 4 * APy * DAy^3 + TX3 + TX4 + TX5
		! IF TX > 0 AND TN # 0 AND TY1 > 0 AND TY2 > 0 THEN
		! 	x = -( (DAy-APy)  *  SQR( TX ) + KX1 ) / TN
		! 	y =  ( (DAx-APx)  *  SQR( TY1 )  *  SQR( TY2 ) + KY1 ) / TN
		! 	ELSE
		! 	x = 0 : y = 0
		! 	ENDIF

		! LÖSUNG B  --> Schnittgerade auf Geradengleichung und Stg. und Konstante in Kreisformel eingesetzt ...
		! ----
		! Geradengleichung {x = mx + d} aus den Schnittpunkten
		! zweier Kreise {(x-A)^2+(y-B)^2=S^2} und {(x-C)^2+(y-D)^2=H^2} ist
		! {2*x*(C-A)+2*y*(D-B)=S^2-A^2-B^2-H^2+C^2+D^2} ergibt:
		! m = (2*A - 2*C) / (2*D - 2*B)
		! d = (S^2 - H^2 + D^2 + C^2 - B^2 - A^2) / (2*D - 2*B)
		! In Kreisformel {(x-A)^2+(y-B)^2=S^2} eingesetzt:
		!   TX1 = -d^2 + (2*B - 2*A*m) * d + (S^2 - A^2) * m^2 + 2*A*B*m + S^2 - B^2
		!   TX2 = m*d - B*m - A
		!   TY1 = -d^2 - 2*A*m*d + 2*B*d + S^2*m^2 - A^2*m^2 + 2*A*B*m + S^2 - B^2
		!   TN  = m^2 + 1
		!   x = ( SQR(TX1) + TX2 ) / TN
		!   y = ( ( m * (A - SQR(TY1)) + d + B*m^2) / TN

		! Gerade...
		TN = 2 * ( APy - DAy )
		IF TN # 0 THEN
			gm  = 2 * ( DAx - APx) / TN
			gd  = ( xH^2 - lG^2 + APx^2 + APy^2 - DAx^2 - DAy^2) / TN
			ELSE
			gm = 0 : gd = 0
			ENDIF

		! ... geschnitten mit Kreis um AP
		TX1 = -gd^2 + (2*APy - 2*APx*gm) * gd + (lG^2 - APx^2) * gm^2 + 2*APx*APy*gm + lG^2 - APy^2
		TX2 = gm * ( APy - gd) + APx
		TY1 = -gd^2 - 2*APx*gm*gd + 2*APy*gd + lG^2*gm^2 - APx^2*gm^2 + 2*APx*APy*gm + lG^2 - APy^2
		TY2 = APy*gm^2 + gd
		TN  = gm^2 + 1

		IF TX1 > 0 AND TN # 0 AND TY1 > 0 THEN
			! x = ( TX2 - SQR( TX1 ) ) / TN
			! y = ( gm * ( APx - SQR( TY1 ) ) + TY2 ) / TN
			x = ( TX2 + SQR( TX1 ) ) / TN
			y = ( gm * ( APx + SQR( TY1 ) ) + TY2 ) / TN
			ELSE
			x = 0 : y = 0
			ENDIF

		! ... geschnitten mit Kreis um DA
		! TX1 = -gd^2 + (2*DAy - 2*DAx*gm) * gd + (xH^2 - DAx^2) * gm^2 + 2*DAx*DAy*gm + xH^2 - DAy^2
		! TX2 = gm * ( DAy - gd) + DAx
		! TY1 = -gd^2 - 2*DAx*gm*gd + 2*DAy*gd + xH^2*gm^2 - DAx^2*gm^2 + 2*DAx*DAy*gm + xH^2 - DAy^2
		! TY2 = DAy*gm^2 + gd
		! TN  = gm^2 + 1

		! IF TX1 > 0 AND TN # 0 AND TY1 > 0 THEN
		! 	! x = ( TX2 - SQR( TX1 ) ) / TN
		! 	! y = ( gm * ( DAx - SQR( TY1 ) ) + TY2 ) / TN
		! 	x = ( TX2 + SQR( TX1 ) ) / TN
		! 	y = ( gm * ( DAx + SQR( TY1 ) ) + TY2 ) / TN
		! 	ELSE
		! 	x = 0 : y = 0
		! 	ENDIF

		ENDIF

	RETURN


! ------------------------------------------------------------------------ Errorcontent:

"debuginfo":

	! »»» Übersetzung der Fehlermeldungen (bitweise)

	txt = ""
	txt2 = ""

	IF BITTEST(sts,0) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Serie"
	IF BITTEST(sts,1) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Brandschutz"
	IF BITTEST(sts,2) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Dämpfung"
	IF BITTEST(sts,3) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Schließkraft"
	IF BITTEST(sts,4) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Schließfunktion"
	IF BITTEST(sts,5) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Schließfolge"
	IF BITTEST(sts,6) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Barrierefreiheit"
	IF BITTEST(sts,7) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Feststellung"
	IF txt # "" THEN
		txt = praefix + "passt nicht zu " + txt + ". "
		praefix = ""
		ELSE
		praefix = STRSUB(praefix,1,4)
		ENDIF

	IF BITTEST(sts2,0) AND bs_door_leafs = 1 THEN txt2 = txt2 + "Passt nicht zu Flügel(anzahl). "
	IF BITTEST(sts2,0) AND bs_door_leafs = 2 THEN txt2 = txt2 + "Nicht bei 2 Türblättern. "
	IF BITTEST(sts2,1) THEN txt2 = txt2 + "Montageseite/Montageposition nicht möglich. "
	IF BITTEST(sts2,2) THEN txt2 = txt2 + "Türblatt zu breit. "
	IF BITTEST(sts2,3) THEN txt2 = txt2 + "Türblatt zu schmal. "
	IF BITTEST(sts2,4) THEN txt2 = txt2 + "Zarge zu schmal. "
	IF BITTEST(sts2,5) THEN txt2 = txt2 + "Türblatt zu dünn. "
	IF BITTEST(sts2,6) THEN txt2 = txt2 + "Zargenfalz nicht tief genug. "
	IF BITTEST(sts2,7) THEN txt2 = txt2 + "Abstand OK Türblatt zu UK Sturz zu gering. "
	IF BITTEST(sts2,8) THEN txt2 = txt2 + "Wandmontage nicht möglich (Sturztiefe/Distanz zu Türblatt). "

	IF BITTEST(sts3,0) THEN txt2 = txt2 + "Schließkörper steht" + infoE + " über Zargenspiegel. "
	IF BITTEST(sts3,1) THEN txt2 = txt2 + "Schiene steht" + infoE + " über Zargenspiegel. "
	IF BITTEST(sts3,2) THEN txt2 = txt2 + "Wandmontage: Schließkörper ragt" + infoE + " über Sturzkante. "
	IF BITTEST(sts3,3) THEN txt2 = txt2 + "Wandmontage: Schiene ragt" + infoE + " über Sturzkante. "
	IF BITTEST(sts3,4) THEN txt2 = txt2 + "Abstand Montageebenen" + infoE + " zu groß. "
	IF txt2 # "" THEN txt = txt + praefix + txt2 

	! IF BITTEST(sts,5) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Kein Platz für Schließkörper"
	! IF BITTEST(sts,5) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Nicht bündig mit Zarge"
	! IF BITTEST(sts,5) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "Leibungstiefe"
	! IF BITTEST(sts,5) THEN txt = txt + STRSUB(", ",1,2*(txt#"")) + "sonstiges"
	! IF txt # "" THEN txt = " ("+txt+")"
	RETURN


"masterend":

! einszwei:  gibt an, ob das Modell ggf. nur für 2 Flügel vorgesehen ist.

